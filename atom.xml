<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>frank0&#39;s Blog</title>
  
  <subtitle>快即是慢，慢即是快</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://frank0.top/"/>
  <updated>2020-05-07T03:33:47.391Z</updated>
  <id>https://frank0.top/</id>
  
  <author>
    <name>frank0</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>商业的本质与互联网略读</title>
    <link href="https://frank0.top/2020/05/07/%E5%95%86%E4%B8%9A%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E7%95%A5%E8%AF%BB/"/>
    <id>https://frank0.top/2020/05/07/%E5%95%86%E4%B8%9A%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E7%95%A5%E8%AF%BB/</id>
    <published>2020-05-07T03:32:03.000Z</published>
    <updated>2020-05-07T03:33:47.391Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本书讲了互联网的历史，一些经济规律与互联网的关系。看似很平常的事情，但是给我耳目一新的感觉，因为之前根本就不知道这些专业名词，对于我这种经济学小白来说，还是有益的。</p></blockquote><a id="more"></a><h3 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h3><h4 id="梅特卡夫效应"><a href="#梅特卡夫效应" class="headerlink" title="梅特卡夫效应"></a>梅特卡夫效应</h4><p>网络具有独特的梅特卡夫效应。不限于互联网，电话网，铁路网也具有。</p><p>鉴于梅特卡夫效应是理解各类互联网商业模式的关键，我们借助一个简单的概念模型，推导出梅特卡夫效应。与成本结构决定的规模效应和协同效应不同，梅特卡夫效应源自网络用户之间的互动，这个概念模型可以清晰地展示这种互动。让我们设想一家电话公司投资9元，架设a、b两人之间的一条电话线（如图4-1中的粗实线所示），两人每月的通话费为10元，公司的利润为1元。我们在这里略去了除投资之外的所有成本，以便尽可能地保持分析的简洁。如果公司想扩大经营规模和经营收入，决定增加b和c之间的一条线，b和c的通话将给公司带来10元的收入。公司的收入翻番至20元，但成本也翻番到18元，利润2元，都是同幅度线性增长。如果公司想进一步扩大规模，是否要投资再建新线呢？不一定。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejpoq7nzcj30eu0bejsl.jpg" alt=""></p><p>公司这时发现，可以利用两条线路实现a、b、c三点之间的通信，而不必架设a到c的线路（图4-1中的细线）。公司只需在节点b安装一台电话交换机，当a和b通话时，交换机阻断来自c的呼叫，以避免干扰a和b，当a和c的讲话结束后，交换机再连接c和a。公司以两条线路的成本18元，产生3倍也就是30元的收入，如果忽略交换机的成本，利润为30-18=12元。换句话说，当节点数从2增加到3，也就是增加了50%，收入和利润分别涨了3倍和12倍！感受到网络的魔力了吧？在经济学中，我们称这一现象为“边际收益递增”，意思是每一新增节点的收益不断上升。即使电话交换机是有成本的，也比建一条a到c的线路要小得多，不会因此颠覆边际收益递增的结论。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejppicojaj30fe0cggns.jpg" alt=""></p><p>让我们继续这个脑力游戏的推理，电话公司再架设一条从c到d的线路，三条线可以使6对客户通话，即ab、ac、ad、bc、bd、cd（见上图），公司的收入增长(60-30)/30=100%，而成本只增加了(27-18)/18=50%，边际收益递增的特征就是收入上涨得比成本更快。推而广之，如果有n-1条线连接第n个客户呢？在这n个人当中，两两通话的可能性有多少？这是一个组合问题，由中学数学知识可知，有n(n-1)/2种可能。如果n=10则有45对节点通话，当n=100时，两人组合的数目达到4950，即电话线路增加10倍，而话费收入增加(4950-45)/45=110倍！电话公司的收入或者网络的价值随用户数呈指数增长，这个关系被称为梅特卡夫定理，用公式表达如下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejpr9j6mcj306802ajrb.jpg" alt=""></p><p>公式中，VM代表具有梅特卡夫效应的网络价值，k1是个常数，n是网络节点或网络用户数。读者需要注意，梅特卡夫定律不是物理学意义上的精确定律，而是从大量观察中得出的统计学意义上的近似公式。2015年，中国科学院的三位研究人员分析了脸书和腾讯的实际数据，证明梅特卡夫定律是成立的，互联网公司的市场价值的确与网络节点数的平方成正比。</p><p>有意思的是，梅特卡夫从对互联网的观察中得出以他命名的定律，<strong>但并不是所有的互联网公司都具有梅特卡夫效应</strong>。这个强大的效应产生于节点间活跃的互动，对于某一类网络，互动仅发生在不同类别的用户之间，例如淘宝和天猫平台上，互动和交易仅在供应商和消费者之间进行，供应商和供应商之间鲜有交易，消费者和消费者老死不相往来。这类互联网平台的价值源于供应方和需求方的相互吸引和相互促进，遵循学术界的惯例，我们称之为<strong>双边市场效应。</strong></p><h4 id="双边市场效应"><a href="#双边市场效应" class="headerlink" title="双边市场效应"></a>双边市场效应</h4><p>我们定义双边市场效应为：<strong>不同类型用户之间正反馈交互所创造的价值</strong>。请注意“不同类型用户”的限定，这意味着<strong>同类用户之间没有互动，双边市场效应因此弱于梅特卡夫效应</strong>。<strong>优步（Uber）等出租车服务平台具有很强的双边市场效应，打车的需求越高，司机的预期收入越高，就有更多的司机加入优步网约车的行列</strong>。另一方面，司机和车辆多，打车就越是方便，并且随着供给的增加，价格会越来越低，于是会吸引更多的消费者。和梅特卡夫效应一样，双边市场效应不是互联网所特有的，甚至不是网络所特有的。实际上，任何一个市场比如浙江义乌小商品市场都可以看到供给和需求的相互促进。采购者愿意去义乌，因为那里有琳琅满目的小商品可供选择。生产厂家愿意在义乌设点，因为那里有来自全国甚至全世界的众多采购者。就供给和需求之间的良性循环而言，义乌和优步没有本质的区别，只不过前者的规模受到物理空间的限制，而后者在互联网虚拟空间中有着似乎是无限的潜力。</p><p>区分双边市场效应和梅特卡夫效应是重要的，在双边市场中，并非任意两个节点都可能产生交互。在大多数情况下，同类用户无交互，如图4-3所示，约车平台上的司机b1和b2之间没有沟通，打车人c1和c2彼此素昧平生。4个节点只有4对可能的互动，即b1c1、b1c2、b2c1、b2c2，而图4-2同样4个节点有6对可能的互动。对比图4-2和图4-3，我们可以清晰地从网络结构以及交互的丰富程度上看出梅特卡夫效应和双边市场效应的差别。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejpuudi14j30ry0i00xx.jpg" alt=""></p><h4 id="规模效应"><a href="#规模效应" class="headerlink" title="规模效应"></a>规模效应</h4><p>规模效益取决于<strong>成本结构</strong>。企业的总成本由<strong>固定成本</strong>和<strong>可变成本</strong>组成，固定成本的比重越大，规模经济效益越好。什么是固定成本？顾名思义，不随产出数量变化的成本，例如厂房、设备、办公楼、电脑信息系统；可变成本则与产量高度相关，像原材料、能源和人工费用，等等。</p><p>为了进一步理解规模效应和成本结构的关系，我们构造一个简单的数值案例。假设一家企业的固定成本为1万元，不妨想象为价值1万元的一台冲压机床，一年折旧完毕，摊入成本。工人操作这台设备将2元一件的薄钢板压制成汤匙，为分析的方便，不考虑材料之外的可变成本如人工、能源等。当产量为1000时，总成本等于固定成本加可变成本即材料费，（10000+2×1000）=12000元，单位成本为12000/1000=12元。如果产量增加到3000，单位成本降到（10000+2×3000）/3000=5.3元。当产量为5000时，单位成本更低，只有（10000+2×5000）/5000=4元。单位成本随产量的增加而递减，在汤匙售价不变的情况下，销售每一汤匙的利润（价格减成本）随产量的增加而上升，这就是规模经济效益。从这个例子可以看出，规模经济效益来自分摊到每单位产品上的固定成本的下降。不难验证，固定成本占总成本的比重越高，规模经济效益越好。假如固定成本等于2万元，可变成本仍是每件2元，产量为1000时，平均成本是22元；当产量增加到5000时，平均成本为6元，单位成本降低了12元。在前面的数值案例中，固定成本为1万元时，产量从1000增加到5000，平均成本只降低了12-4=8元。</p><p><strong>需要注意的是，固定成本并非一成不变，经济学教科书经常有这样的表述：固定成本短期不变，长期可变。</strong>这个表述不是很准确，影响固定成本的主要不是时间，而是产量和设计产能。如果一条手机生产线的设计能力是一年10万部，当产量超过10万，比如说达到11万时，厂家就要投资另建一条线，固定成本因此而陡增。互联网公司也是这样，在流量和数据量大到现有数据中心无法承接时，必须投建新机房，购买更多服务器。画成图像的话，横轴是产量，固定成本是一条阶梯形上升的折线。对比之下，餐饮、零售等行业不需要多少固定资产投资，房屋店面都不必自己拥有，租用即可，因而对经营规模的要求比较低，小餐馆、小商店遍地开花，小本生意也可赢利。</p><p>规模不可怕，可怕的是同质化，是缺乏创新的能力。很典型的例子，阿里的来往、腾讯的微信、阿里的钉钉</p><h4 id="协同效应"><a href="#协同效应" class="headerlink" title="协同效应"></a>协同效应</h4><p>与规模效应类似又不尽相同，区别在于前者和单一产品的数量相关，而后者取决于品种的丰富程度。</p><p>腾讯建设和维护微信成本是固定的，微信平台上承载的服务越多，电商、广告、游戏、支付、理财、银行等，各项服务的供应商越多，腾讯公司的效益就越好。苹果公司的协同效应体现在数以百万计的App上，新增一个App，比如说爱奇艺，并不消耗苹果的任何资源，却给苹果带来新的收入，即爱奇艺支付的平台使用费。当然，羊毛出在羊身上，最终埋单的还是爱奇艺的用户，消费者成为付费会员后，才能下载它的一些音像产品。免费的音乐和视频虽然也有，但消费者必须先看一两分钟烦人的广告，做广告的商家构成爱奇艺的另一重要收入来源。商家之间的协同也不可忽视，百货大楼里热销的新款跑步鞋有可能带动邻近帽子店的销售。在京东上买了手电，顺便再下单订两节电池。商品种类越是齐全，客户购买的便利性体验越好，百货公司或电商的收入也就越高。</p><p>与双边市场效应不同，这个协同效应是品类的丰富。双边市场效应是两边的规模增加而不是品类增加。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="淘宝-天猫"><a href="#淘宝-天猫" class="headerlink" title="淘宝/天猫"></a>淘宝/天猫</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejq2zzk21j30q40n0dn3.jpg" alt=""></p><p>是一个交易平台，和电商有本质区别；盈利模式是收取交易手续费。</p><p>具有双边市场效应，具有规模效应与协同效应，不具有梅特卡夫效应，</p><h4 id="京东-亚马逊"><a href="#京东-亚马逊" class="headerlink" title="京东/亚马逊"></a>京东/亚马逊</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejq2hgfryj30v40kmn1b.jpg" alt=""></p><p>是一个电商，依靠赚取差价获利。</p><p>不具有梅特卡夫效应，不具有双边市场效应，具有规模效应与协同效应</p><h4 id="共享经济"><a href="#共享经济" class="headerlink" title="共享经济"></a>共享经济</h4><p>本质上只是使用了互联网工具的出租公司。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejq4lawnqj30zs0eqtbw.jpg" alt=""></p><h4 id="图书信息"><a href="#图书信息" class="headerlink" title="图书信息"></a>图书信息</h4><p>《信息规则：网络经济的战略方向》</p><p>《长尾理论》</p><p>《平台革命》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本书讲了互联网的历史，一些经济规律与互联网的关系。看似很平常的事情，但是给我耳目一新的感觉，因为之前根本就不知道这些专业名词，对于我这种经济学小白来说，还是有益的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Thymeleaf-Layout引起的内存泄露</title>
    <link href="https://frank0.top/2020/04/22/Thymeleaf-Layout-GC-Error/"/>
    <id>https://frank0.top/2020/04/22/Thymeleaf-Layout-GC-Error/</id>
    <published>2020-04-22T04:17:43.000Z</published>
    <updated>2020-04-22T10:58:58.198Z</updated>
    
    <content type="html"><![CDATA[<p>最近线上维护的一个程序经过微服务化之后，出现了很多GC，而且内存被耗尽，小网站，不应该耗尽4G内存,调查了一下原因，原来是</p><a id="more"></a><p>服务器硬件信息：</p><p>SSD: 80 GB RAID-10<br>RAM: 4096 MB<br>CPU: 2x Intel Xeon</p><p>软件信息：</p><p>MySQL,Redis,JDK8,SpringBoot,Thymeleaf</p><p>JVM参数：<code>/opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.0.0.1-SNAPSHOT.jar --spring.profiles.active=online</code></p><p>用来跑了一些Java程序，运行一天之后，出现OOM异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br></pre></td></tr></table></figure><p>GC overhead limit exceeded异常，GOOGLE一番：</p><p>The <em>java.lang.OutOfMemoryError: GC overhead limit exceeded</em> error is the JVM’s way of signalling that your application spends too much time doing garbage collection with too little result. By default the JVM is configured to throw this error if it spends more than <strong>98% of the total time doing GC and when after the GC only less than 2% of the heap is recovered</strong>.</p><p>JVM抛出 <em>java.lang.OutOfMemoryError: GC overhead limit exceeded</em> 错误就是发出了这样的信号: 执行垃圾收集的时间比例太大, 有效的运算量太小. 默认情况下, 如果GC花费的时间超过 <strong>98%</strong>, 并且GC回收的内存少于 <strong>2%</strong>, JVM就会抛出这个错误。</p><p>接着，我们看下JVM内存分配：</p><p>使用<code>JPS</code>命令找出pid，使用<code>JMAP -heap ${pid}</code> 打印内存信息：</p><p>问题现场 heap信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 1638, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.191-b12</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2621440000 (2500.0MB)</span><br><span class="line">   NewSize                  = 873463808 (833.0MB)</span><br><span class="line">   MaxNewSize               = 873463808 (833.0MB)</span><br><span class="line">   OldSize                  = 1747976192 (1667.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 389021696 (371.0MB)</span><br><span class="line">   used     = 389021696 (371.0MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 218103808 (208.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 218103808 (208.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 242745344 (231.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 242745344 (231.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 1747976192 (1667.0MB)</span><br><span class="line">   used     = 1747822160 (1666.8531036376953MB)</span><br><span class="line">   free     = 154032 (0.1468963623046875MB)</span><br><span class="line">   99.99118798066559% used</span><br></pre></td></tr></table></figure><p>很显然，Eden区 和Old 区都耗尽了。</p><p>我想知道新生代和老年代都存了些什么，使用命令<code>jmap -dump:live,format=b,file=dump.file ${pid}</code> </p><p>只导出存活对象的堆栈信息</p><p>大概有3个G</p><p>使用工具分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The class "nz.net.ultraq.thymeleaf.context.extensions.IContextExtensions", loaded by "org.springframework.boot.loader.LaunchedURLClassLoader @ 0x7252ae050", occupies 2,099,455,296 (96.06%) bytes. The memory is accumulated in one instance of "java.util.LinkedHashMap" loaded by "&lt;system class loader&gt;".</span><br><span class="line"></span><br><span class="line">Keywords</span><br><span class="line">java.util.LinkedHashMap</span><br><span class="line">nz.net.ultraq.thymeleaf.context.extensions.IContextExtensions</span><br><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader @ <span class="number">0x7252ae050</span></span><br></pre></td></tr></table></figure><p>爆出了内存泄露风险：</p><p>继续看，主要看这个<code>Accumulated Objects in Dominator Tree</code>看看对象数量：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2fux0uq5j316a0gg7co.jpg" alt=""></p><p>96%的空间都被 thymeleaf context占用了</p><p>怀疑这个有内存泄露，这个类是使用thymeleaf的layout功能，第三方的jar包</p><p>google一番，github上面已经有人爆出了类似的BUG：</p><p><a href="https://github.com/ultraq/thymeleaf-layout-dialect/issues/139" target="_blank" rel="noopener">https://github.com/ultraq/thymeleaf-layout-dialect/issues/139</a></p><p><a href="https://github.com/ultraq/thymeleaf-layout-dialect/issues/122" target="_blank" rel="noopener">https://github.com/ultraq/thymeleaf-layout-dialect/issues/122</a></p><p>然后看帖子说，2.1.0已经解决了</p><p>看了下我用的版本是2.0.1 赶紧升级了最新版本；</p><p>运行一天结果：</p><p><code>jmap -heap ${pid}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID <span class="number">11332</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.191</span>-b12</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">4</span> thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2621440000</span> (<span class="number">2500.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">873463808</span> (<span class="number">833.0</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">873463808</span> (<span class="number">833.0</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">1747976192</span> (<span class="number">1667.0</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">829423616</span> (<span class="number">791.0</span>MB)</span><br><span class="line">   used     = <span class="number">23825784</span> (<span class="number">22.72203826904297</span>MB)</span><br><span class="line">   free     = <span class="number">805597832</span> (<span class="number">768.277961730957</span>MB)</span><br><span class="line">   <span class="number">2.8725712097399456</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">21495808</span> (<span class="number">20.5</span>MB)</span><br><span class="line">   used     = <span class="number">17248552</span> (<span class="number">16.449501037597656</span>MB)</span><br><span class="line">   free     = <span class="number">4247256</span> (<span class="number">4.050498962402344</span>MB)</span><br><span class="line">   <span class="number">80.24146847608613</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">1747976192</span> (<span class="number">1667.0</span>MB)</span><br><span class="line">   used     = <span class="number">102638624</span> (<span class="number">97.88381958007812</span>MB)</span><br><span class="line">   free     = <span class="number">1645337568</span> (<span class="number">1569.1161804199219</span>MB)</span><br><span class="line">   <span class="number">5.8718548038439184</span>% used</span><br></pre></td></tr></table></figure><p>可以看到，已经正常了；</p><p>继续看一下GC频率:<code>jstat -gc ${pid}</code></p><p>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>21504.0 21504.0  0.0   16127.9 809984.0 493815.0 1707008.0   100273.0  112844.0 107384.9 13056.0 12026.0    149    4.369   4      1.156    5.525</p><p>S0C 代表 S0 capacity S0 大小，注意单位是KB 大概21M左右</p><p>S1C代表 S1 capacity S1 大小，注意单位是KB 大概21M左右</p><p>S0U 代表 S0 used capacity ，S0区使用空间 同理 S1U代表 S1区使用空间</p><p>同理其他, C代表初始空间 U代表使用空间，YGC 代表youngCG (count)次数，FGCT 代表 young GC (cost time)</p><p>可以看到，Young GC 次数达到了149次，耗时4.369 s</p><p>继续看看垃圾回收日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T03:<span class="number">49</span>:<span class="number">51.797</span>+<span class="number">0800</span>: <span class="number">32225.690</span>: [GC (Allocation Failure)  <span class="number">926931</span>K-&gt;<span class="number">105742</span>K(<span class="number">2545152</span>K), <span class="number">0.0287966</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T03:<span class="number">57</span>:<span class="number">13.735</span>+<span class="number">0800</span>: <span class="number">32667.628</span>: [GC (Allocation Failure)  <span class="number">929038</span>K-&gt;<span class="number">106728</span>K(<span class="number">2545152</span>K), <span class="number">0.0513608</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">03</span>:<span class="number">53.071</span>+<span class="number">0800</span>: <span class="number">33066.965</span>: [GC (Allocation Failure)  <span class="number">930024</span>K-&gt;<span class="number">105097</span>K(<span class="number">2545152</span>K), <span class="number">0.0322447</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">11</span>:<span class="number">00.399</span>+<span class="number">0800</span>: <span class="number">33494.292</span>: [GC (Allocation Failure)  <span class="number">928393</span>K-&gt;<span class="number">105856</span>K(<span class="number">2545152</span>K), <span class="number">0.0323377</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">20</span>:<span class="number">46.614</span>+<span class="number">0800</span>: <span class="number">34080.507</span>: [GC (Allocation Failure)  <span class="number">929152</span>K-&gt;<span class="number">107559</span>K(<span class="number">2544640</span>K), <span class="number">0.0285097</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">29</span>:<span class="number">45.171</span>+<span class="number">0800</span>: <span class="number">34619.064</span>: [GC (Allocation Failure)  <span class="number">930855</span>K-&gt;<span class="number">106868</span>K(<span class="number">2545152</span>K), <span class="number">0.0304927</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">37</span>:<span class="number">42.922</span>+<span class="number">0800</span>: <span class="number">35096.815</span>: [GC (Allocation Failure)  <span class="number">930164</span>K-&gt;<span class="number">106172</span>K(<span class="number">2545664</span>K), <span class="number">0.0277129</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">42</span>:<span class="number">42.121</span>+<span class="number">0800</span>: <span class="number">35396.014</span>: [GC (Allocation Failure)  <span class="number">929980</span>K-&gt;<span class="number">104085</span>K(<span class="number">2545152</span>K), <span class="number">0.0260993</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">50</span>:<span class="number">59.664</span>+<span class="number">0800</span>: <span class="number">35893.557</span>: [GC (Allocation Failure)  <span class="number">927893</span>K-&gt;<span class="number">106575</span>K(<span class="number">2545664</span>K), <span class="number">0.0233603</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">57</span>:<span class="number">57.947</span>+<span class="number">0800</span>: <span class="number">36311.840</span>: [GC (Allocation Failure)  <span class="number">930383</span>K-&gt;<span class="number">106330</span>K(<span class="number">2545152</span>K), <span class="number">0.0338124</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T05:<span class="number">04</span>:<span class="number">59.016</span>+<span class="number">0800</span>: <span class="number">36732.909</span>: [GC (Allocation Failure)  <span class="number">930138</span>K-&gt;<span class="number">106005</span>K(<span class="number">2546176</span>K), <span class="number">0.0251955</span> secs]</span><br></pre></td></tr></table></figure><p>很多的 YGC ，可以看到 old区分配多，但是一直使用很少，我们需要把Eden区适当的调大一些</p><p>修改启动参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -XX:NewRatio=1 -XX:SurvivorRatio=6 -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.jar --spring.profiles.active=online &amp;</span><br></pre></td></tr></table></figure><p><code>jmap -heap pid</code>看下是否修改成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2621440000</span> (<span class="number">2500.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">1</span></span><br><span class="line">   SurvivorRatio            = <span class="number">6</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">1220542464</span> (<span class="number">1164.0</span>MB)</span><br><span class="line">   used     = <span class="number">323484472</span> (<span class="number">308.4988327026367</span>MB)</span><br><span class="line">   free     = <span class="number">897057992</span> (<span class="number">855.5011672973633</span>MB)</span><br><span class="line">   <span class="number">26.503336142838204</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">37224448</span> (<span class="number">35.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">37224448</span> (<span class="number">35.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">48758784</span> (<span class="number">46.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">48758784</span> (<span class="number">46.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   used     = <span class="number">85510744</span> (<span class="number">81.54940032958984</span>MB)</span><br><span class="line">   free     = <span class="number">1225209256</span> (<span class="number">1168.4505996704102</span>MB)</span><br><span class="line">   <span class="number">6.523952026367187</span>% used</span><br></pre></td></tr></table></figure><p>修改成功，看下 <code>jstat -gc pid</code></p><p>还是有FGC 和YGC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"><span class="number">47616.0</span> <span class="number">36352.0</span>  <span class="number">0.0</span>    <span class="number">0.0</span>   <span class="number">1191936.0</span> <span class="number">672473.0</span> <span class="number">1280000.0</span>   <span class="number">83506.6</span>   <span class="number">98380.0</span> <span class="number">94049.5</span> <span class="number">12160.0</span> <span class="number">11320.6</span>      <span class="number">7</span>    <span class="number">0.322</span>   <span class="number">4</span>      <span class="number">0.939</span>    <span class="number">1.262</span></span><br></pre></td></tr></table></figure><p>继续看下日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T10:<span class="number">56</span>:<span class="number">37.707</span>+<span class="number">0800</span>: <span class="number">17.685</span>: [<span class="function">Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  44082K-&gt;42892<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.1144814 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:41.840+0800: 21.817: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  884284K-&gt;49863<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0497769 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:41.889+0800: 21.867: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  49863K-&gt;30535<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.1049150 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:47.095+0800: 27.073: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  991047K-&gt;45635<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0237439 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:51.833+0800: 31.810: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  841845K-&gt;56284<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0595819 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:51.892+0800: 31.870: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  56284K-&gt;53312<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.2826614 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:57:00.632+0800: 40.609: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  1013824K-&gt;70909<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0262383 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:57:37.503+0800: 77.480: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  1031421K-&gt;85407<span class="title">K</span><span class="params">(<span class="number">2513920</span>K)</span>, 0.0557805 secs]</span></span><br><span class="line"><span class="function">2020-04-21T11:00:13.790+0800: 233.767: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  715074K-&gt;89727<span class="title">K</span><span class="params">(<span class="number">2508288</span>K)</span>, 0.0624448 secs]</span></span><br><span class="line"><span class="function">2020-04-21T11:00:13.853+0800: 233.830: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  89727K-&gt;83506<span class="title">K</span><span class="params">(<span class="number">2508288</span>K)</span>, 0.4372935 secs]</span></span><br></pre></td></tr></table></figure><p>可以看到是由于Metadata GC Threshold触发了FGC；MetaspaceSize 太小了。继续修改，增加参数：</p><p><code>-XX:MetaspaceSize=128M</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -XX:NewRatio=1 -XX:SurvivorRatio=6 -XX:MetaspaceSize=128M -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.jar --spring.profiles.active=online &amp;</span><br></pre></td></tr></table></figure><p>好了，GC基本没有，跑段时间在看</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近线上维护的一个程序经过微服务化之后，出现了很多GC，而且内存被耗尽，小网站，不应该耗尽4G内存,调查了一下原因，原来是&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kyro序列化错误</title>
    <link href="https://frank0.top/2019/11/21/kyro-error/"/>
    <id>https://frank0.top/2019/11/21/kyro-error/</id>
    <published>2019-11-21T10:59:09.000Z</published>
    <updated>2020-04-22T11:00:36.565Z</updated>
    
    <content type="html"><![CDATA[<p>Kryo序列化时报错：java.lang.ArrayIndexOutOfBoundsException、Buffer overflow</p><p>序列化二进制文件不完整</p><a id="more"></a><p>问题：</p><ol><li>序列化对象不完整</li><li>序列化对象比较慢，耗时10-14ms之内</li><li>解决比较慢的问题之后，又出现对象序列化数据不完整问题</li></ol><p>java序列化与kryo序列化得区别？</p><ol><li>效率比java序列化高，官方网站有性能测试</li><li>kryo不需要实现Serializable接口，而Java需要实现序列化接口</li><li>java 序列化支持实例化类的改变，但是kryo不支持；已经经过测试代码证实；</li><li>只导出存活对象的堆栈信息</li></ol><p>正确使用kryo的姿势：</p><ol><li>使用对象池来解决非线程安全的问题</li><li>使用Kryo提供的Output对象来获取byte数组，而Output是支持自动扩容的，大于4M的时候；</li></ol><p>池化技术：</p><p>数据库连接池，http连接池等；重复利用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化kryo池</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KryoPool kryoPool = <span class="keyword">new</span> KryoPool.Builder(<span class="keyword">new</span> KryoFactory() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Kryo <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">           kryo.setInstantiatorStrategy(<span class="keyword">new</span> Kryo.DefaultInstantiatorStrategy(<span class="keyword">new</span> StdInstantiatorStrategy()));</span><br><span class="line">           <span class="keyword">return</span> kryo;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).softReferences().build();</span><br></pre></td></tr></table></figure><p>Kryo池化，主要使用一个软引用队列，如果队列没有则使用工厂创建一个，如果队列有则从队列出队给使用者使用；</p><p>使用者使用完之后，进行释放，则kryo对象入队；这样保证kryo的重复利用；</p><p>自动扩容：</p><p>之前的错误原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates a new Output for writing to an OutputStream. A buffer size of 4096 is used. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Output</span> <span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">if</span> (outputStream == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"outputStream cannot be null."</span>);</span><br><span class="line"><span class="keyword">this</span>.outputStream = outputStream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Output</span> <span class="params">(<span class="keyword">int</span> bufferSize, <span class="keyword">int</span> maxBufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bufferSize &gt; maxBufferSize &amp;&amp; maxBufferSize != -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"bufferSize: "</span> + bufferSize + <span class="string">" cannot be greater than maxBufferSize: "</span> + maxBufferSize);</span><br><span class="line"><span class="keyword">if</span> (maxBufferSize &lt; -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxBufferSize cannot be &lt; -1: "</span> + maxBufferSize);</span><br><span class="line"><span class="keyword">this</span>.capacity = bufferSize;</span><br><span class="line"><span class="keyword">this</span>.maxCapacity = maxBufferSize == -<span class="number">1</span> ? Integer.MAX_VALUE : maxBufferSize;</span><br><span class="line">buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码以为是最大maxBuffer都是4KB导致的；其实不是，kryo支持自动扩容：</p><p>上面这个构造函数，如果指定了外部的一个OutputStream的话，他会每次达到Output的buffer的4096字节后，执行一次刷新操作，把这4096字节刷新到指定的那个输出流，然后清空buffer，继续执行序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeVarInt</span> <span class="params">(<span class="keyword">int</span> value, <span class="keyword">boolean</span> optimizePositive)</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!optimizePositive) value = (value &lt;&lt; <span class="number">1</span>) ^ (value &gt;&gt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">if</span> (value &gt;&gt;&gt; <span class="number">7</span> == <span class="number">0</span>) &#123;</span><br><span class="line">require(<span class="number">1</span>);</span><br><span class="line">buffer[position++] = (<span class="keyword">byte</span>)value;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> true if the buffer has been resized. */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">require</span> <span class="params">(<span class="keyword">int</span> required)</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line">        <span class="comment">//初始容量够用</span></span><br><span class="line"><span class="keyword">if</span> (capacity - position &gt;= required) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 申请空间大于最大容量值</span></span><br><span class="line">        <span class="keyword">if</span> (required &gt; maxCapacity)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(<span class="string">"Buffer overflow. Max capacity: "</span> + maxCapacity + <span class="string">", required: "</span> + required);</span><br><span class="line">        <span class="comment">//刷新缓存</span></span><br><span class="line">flush();</span><br><span class="line">        <span class="comment">//如果没有使用 outputStream，则需要设置最大容量，未超过最大容量则自动扩容</span></span><br><span class="line"><span class="keyword">while</span> (capacity - position &lt; required) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == maxCapacity)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(<span class="string">"Buffer overflow. Available: "</span> + (capacity - position) + <span class="string">", required: "</span> + required);</span><br><span class="line"><span class="comment">// Grow buffer.</span></span><br><span class="line">            <span class="comment">//自动扩容</span></span><br><span class="line"><span class="keyword">if</span> (capacity == <span class="number">0</span>) capacity = <span class="number">1</span>;</span><br><span class="line">capacity = Math.min(capacity * <span class="number">2</span>, maxCapacity);</span><br><span class="line"><span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) capacity = maxCapacity;</span><br><span class="line"><span class="keyword">byte</span>[] newBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[capacity];</span><br><span class="line">System.arraycopy(buffer, <span class="number">0</span>, newBuffer, <span class="number">0</span>, position);</span><br><span class="line">buffer = newBuffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Writes the buffered bytes to the underlying OutputStream, if any. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span> <span class="params">()</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有设置outputStream 则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (outputStream == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//刷缓存到outputStream</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream.write(buffer, <span class="number">0</span>, position);</span><br><span class="line">outputStream.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(ex);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//重置当前写入位置</span></span><br><span class="line">total += position;</span><br><span class="line">position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，正确使用kryo的用法有两种：</p><ul><li>使用最大容量控制对象大小，此时如果序列化大对象超过则扩容，需要设置maxCapacity</li><li>使用outputStream来获取真实的对象字节流，这个kryo会自动刷缓存到outputStream中。无需设置maxCapacity</li></ul><p>使用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用outputStream，需要使用size控制</span></span><br><span class="line">Output output = <span class="keyword">new</span> Output(<span class="number">4096</span>,<span class="number">4096</span>*<span class="number">4</span>);</span><br><span class="line">kryo = kryoPool.borrow();</span><br><span class="line">kryo.writeObject(output, obj);</span><br><span class="line">output.close();</span><br><span class="line">bytes[] bytes = output.toBytes();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 使用outputStream</span></span><br><span class="line">         ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         Output output = <span class="keyword">new</span> Output(outputStream);</span><br><span class="line">         kryo = kryoPool.borrow();</span><br><span class="line">         kryo.writeObject(output, obj);</span><br><span class="line">         output.close();</span><br><span class="line"><span class="comment">//此处需要注意，outputStream的结果输出</span></span><br><span class="line">         bytes = outputStream.toByteArray();</span><br></pre></td></tr></table></figure><p>之前的代码把这两种方式进行混用了。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerialize</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TestSerialize t = <span class="keyword">new</span> TestSerialize();</span><br><span class="line">        <span class="comment">//t.testKryo();</span></span><br><span class="line">        t.testKryoD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKryo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        u.setName(<span class="string">"sdfsdf"</span>);</span><br><span class="line">        u.setUserId(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] serialize = KryoSerializer.serialize(u);</span><br><span class="line">        FileOutputStream fileWriter = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/k.bin"</span>));</span><br><span class="line">        fileWriter.write(serialize);</span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKryoD</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"d:/k.bin"</span>));</span><br><span class="line">        <span class="comment">//当文件没有结束时，每次读取一个字节显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(data);</span><br><span class="line">        in.close();</span><br><span class="line">        User user = KryoSerializer.deSerialize(data, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJava</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//        u.setUserId(1);</span></span><br><span class="line">        u.setName(<span class="string">"2323"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] serialize = JavaSerializer.serialize(u);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileWriter = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/u.bin"</span>));</span><br><span class="line">        fileWriter.write(serialize);</span><br><span class="line">        fileWriter.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJavaD</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"d:/u.bin"</span>));</span><br><span class="line">        <span class="comment">//当文件没有结束时，每次读取一个字节显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(data);</span><br><span class="line">        in.close();</span><br><span class="line">        User user = JavaSerializer.deSerialize(data, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">229880032075948565L</span>;</span><br><span class="line">        <span class="keyword">private</span> Integer userId;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kryo序列化时报错：java.lang.ArrayIndexOutOfBoundsException、Buffer overflow&lt;/p&gt;
&lt;p&gt;序列化二进制文件不完整&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDK8-dynamic-proxy</title>
    <link href="https://frank0.top/2019/04/16/JDK8-dynamic-proxy/"/>
    <id>https://frank0.top/2019/04/16/JDK8-dynamic-proxy/</id>
    <published>2019-04-16T09:28:00.000Z</published>
    <updated>2020-04-22T10:43:17.706Z</updated>
    
    <content type="html"><![CDATA[<p>Jdk动态代理（基于JDK8）原理浅析</p><a id="more"></a><blockquote><p>Jdk动态代理（基于JDK8）原理浅析</p></blockquote><p>JDK动态代理很容易使用，但是光知道使用不行，还得知道JDK的动态代理是怎么实现的。<br>我们例子:<br>定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Click</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickImpl</span> <span class="keyword">implements</span> <span class="title">Click</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call click action..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理的InvokerHandler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickInvokerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClickInvokerHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般此类可以使用单例模式；<br>测试JDK动态代理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; proxyClass= Proxy.getProxyClass(JdkProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">Click</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = proxyClass.getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = <span class="keyword">new</span> ClickInvokerHandler(<span class="keyword">new</span> ClickImpl());</span><br><span class="line">        Click click= (Click)cons.newInstance(ih);</span><br><span class="line">        click.click();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        Click click1=(Click)Proxy.</span><br><span class="line">                newProxyInstance(JdkProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                        new Class&lt;?&gt;[]&#123;Click.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> ClickInvokerHandler(<span class="keyword">new</span> ClickImpl()));</span><br><span class="line">        click1.click();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call click action...</span><br><span class="line">--------------------------------</span><br><span class="line">call click action...</span><br></pre></td></tr></table></figure><p>下面我们带着两个问题看Jdk动态代理原理：</p><ul><li>怎么生成代理类？</li><li>InvokerHandler的invoker方法是谁在调用？</li><li>生成的代理类如何加载到JVM中?</li></ul><p>#####如果生成代理类？</p><p>我们可以看看<code>Proxy.newProxyInstance</code>方法<br>此方法需要三个参数，classLoader,接口定义类数组(click.class),InvocationHandler 实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line">     Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是生成了代理类，我们继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先从缓存中获取，如果没有创建过，则使用ProxyClassFactory进行创建</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从proxyClassCache中获取，我们看看proxyClassCache怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>感兴趣的可以看看这个<code>WeakCache</code>get()方法，使用了内部类<code>ProxyClassFactory.apply()</code>来创建代理类，并缓存。<br>1.apply方法里面定义了代理类的类名；<br>2.生成代理类的字节码，并加载代理类；<br>生成代理类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure><p><code>generateProxyClass</code>方法中调用<code>generateClassFile</code>方法生成class文件；<br>可以使用<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>参数来配置，是否保存生成的代理类的class文件；<br>感兴趣的可以看下<code>generateClassFile</code>这个方法；这个方法默认实现了，Object的hashCode,equals,toString方法；</p><p>加载类使用我们classloader来加载：<br>这个方法是个<code>native</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length)</span><br></pre></td></tr></table></figure><p>OK,到这里我们看到了怎么生成代理类；这个代理类怎么加载到JVM；<br>但是我们还没有看到：invokerHandler的invoker方法何时被调用？<br>我们设置配置：<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>为true；<br>然后可以看到已经生成了代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Click</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">////...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">////...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">       <span class="comment">//...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.tsoft.learning.proxy.dynamic.Click"</span>).getMethod(<span class="string">"click"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类继承至<code>Proxy</code>类，实现了<code>Click</code>接口。<br>注意static静态块中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m3 = Class.forName(<span class="string">"com.tsoft.learning.proxy.dynamic.Click"</span>).getMethod(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure><p>从接口中获取方法，如果需要代理接口中没有的方法，就不能使用JDK动态代理。此时，我们需要依靠cglib来做动态代理了。这就是为什么JDK的动态代理需要实现接口的原因。<br>我们在看看 <code>$Proxy0</code>中的<code>click</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>里面实际上调用super.h.invoke这个方法，  而这个h对象就是我们的之前的入参：<code>ClickInvokerHandler</code>对象；这个对象是使用构成方法注入进去的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ok，到此，我们提出的三个问题已经回答完毕。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jdk动态代理（基于JDK8）原理浅析&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
