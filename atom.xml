<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>frank0&#39;s Blog</title>
  
  <subtitle>人生不是拥有多少，而是经历多少</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://frank0.top/"/>
  <updated>2020-09-24T08:25:50.584Z</updated>
  <id>https://frank0.top/</id>
  
  <author>
    <name>frank0</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Redis基础4_数据持久化之RDB</title>
    <link href="https://frank0.top/2020/09/24/Redis%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/"/>
    <id>https://frank0.top/2020/09/24/Redis%E5%9F%BA%E7%A1%80-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BRDB/</id>
    <published>2020-09-24T08:24:18.000Z</published>
    <updated>2020-09-24T08:25:50.584Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>上篇说了Redis持久化之AOF，他有利也有弊，利是每次执行时追加的AOF数据不多，只要不配置成Always效率影响不会很大，弊是当我们需要恢复数据时，因为是每个命令都写入了AOP所以恢复时间比较长，所以出现了另外一种持久化方法 RDB：把Redis的数据快照 保存下来，因为保存的全是数据，所以恢复时直接写入内存即可，恢复速度比较快。</p></blockquote><a id="more"></a><p>使用RDB持久化，需要搞清楚两个问题：</p><ol><li>是否阻塞线程？服务器是否能够继续处理请求？</li><li>每次持久化是全量数据吗？</li></ol><h4 id="是否阻塞线程？服务器是否能够继续处理请求？？"><a href="#是否阻塞线程？服务器是否能够继续处理请求？？" class="headerlink" title="是否阻塞线程？服务器是否能够继续处理请求？？"></a>是否阻塞线程？服务器是否能够继续处理请求？？</h4><p>RDB持久化有两个命令： <code>save</code> 和 <code>bgsave</code> save是在主线程中执行，会阻塞线程；<code>bgsave</code>不会阻塞线程，由于是fork出子线程进行RDB持久化，那么服务器就可以继续处理请求，读请求还好说，不改变内存数据，那么写请求时，redis如何处理？而且redis使用RDB持久化，是持久化<code>全量快照数据</code>，当数据量很大时，效率必定不会很高。</p><p>但是，这时RedisServer 是可以处理写请求的，他是怎么处理的？</p><p>注意上面<code>bgsave</code>命令是fork出子线程，这时子线程是可以访问父进程的内存数据的，Redis就利用操作系统的<a href="https://www.cnblogs.com/biyeymyhjob/archive/2012/07/20/2601655.html" target="_blank" rel="noopener">写时复制</a>技术，把父进程修改的数据，复制一份给子进程，这样子进程还是保存的是最新的数据，父进行还是可以处理写请求。</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200924155944631.png" alt="image-20200924155944631" style="zoom:50%;" /><h4 id="每次持久化是全量数据吗？"><a href="#每次持久化是全量数据吗？" class="headerlink" title="每次持久化是全量数据吗？"></a>每次持久化是全量数据吗？</h4><p>如果内存数据很多很大，每次持久化全量数据势必会影响效率，所以Redis4.0以后有了“增量快照功能”，其实是全量快照+AOF日志结合起来使用，第一次全量快照后，每隔一段时间再次做全量快照；两次全量快照的时间间隔间，使用AOF日志记录变化的数据。</p><p>如图：</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200924161409328.png" alt="image-20200924161409328" style="zoom:50%;" /><p>假如，在两次全量快照的时间之中，发生了宕机，可以使用RDB来快速恢复数据，同时利用AOF日志来做增量恢复。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;上篇说了Redis持久化之AOF，他有利也有弊，利是每次执行时追加的AOF数据不多，只要不配置成Always效率影响不会很大，弊是当我们需要恢复数据时，因为是每个命令都写入了AOP所以恢复时间比较长，所以出现了另外一种持久化方法 RDB：把Redis的数据快照 保存下来，因为保存的全是数据，所以恢复时直接写入内存即可，恢复速度比较快。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="redis" scheme="https://frank0.top/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis基础3_数据持久化之AOF</title>
    <link href="https://frank0.top/2020/09/11/Redis%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/"/>
    <id>https://frank0.top/2020/09/11/Redis%E5%9F%BA%E7%A1%803-%E6%95%B0%E6%8D%AE%E6%8C%81%E4%B9%85%E5%8C%96%E4%B9%8BAOF/</id>
    <published>2020-09-11T09:06:06.000Z</published>
    <updated>2020-09-11T09:08:02.754Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p> Redis有两种数据持久化的方式，他们都有各自的特点，写下AOF持久化的总结。</p></blockquote><a id="more"></a><h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><p>AOF是Append Only File 的简称，AOF是利用日志来记录Redis的操作命令，然后在使用他恢复Redis数据。</p><p>提到日志，有两个很经典的应用场景，MySQL的两阶段提交，就是利用日志来实现的，还有消息队列如rocketMQ也是利用写日志来记录数据，但是有个明显的区别，他们一般是先写日志，后刷盘这样能够避免数据丢失，<strong>但是Redis不一样，Redis是先执行命令后写日志</strong>。</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200911160600899.png" alt="image-20200911160600899" style="zoom:50%;" /><p>如果这时候，Redis写了内存，还没有写日志，挂掉了怎么办？数据还能恢复吗？</p><p>答案是不能，所以会有数据丢失的风险。</p><p>那为什么Redis会选择这种方式？</p><ol><li>由于AOF日志记录的是Redis的命令，后写日志避免了AOF日志记录错误的命令（为什么不检查正确后在写日志？）</li><li>由于Redis处理数据时是单线程，如果先写日志，当磁盘有性能问题时，会有阻塞当前请求的线程的风险，但是这种风险避免不了。为啥？因为后写日志，如果你磁盘有问题，会影响下次请求。（写AOF日志是在主线程中完成）</li></ol><p><strong>所以，为了避免磁盘引发的风险，Redis提供了三种AOF写回策略。</strong></p><p>appendfsync 配置：</p><p>Always：每次执行完命令，立刻写AOF日志到磁盘</p><p>Everysec： 每秒写回，命令执行完，先把AOF日志写到内存缓冲区，每隔一秒把内存缓存区的AOF日志写到磁盘</p><p>No： 操作系统控制写回，命令执行完，先把AOF日志写到内存缓冲区，由操作系统决定何时写回磁盘。</p><blockquote><p><strong>操作系统何时写回磁盘？</strong></p><p>在现代操作系统中， 当用户调用 <code>write</code> 函数， 将一些数据写入到文件的时候， 操作系统通常会将写入数据暂时保存在一个内存缓冲区里面， 等到缓冲区的空间被填满、或者超过了指定的时限之后， 才真正地将缓冲区中的数据写入到磁盘里面。也就是说如果你不强制调用系统的同步函数，这个权限就交给操作系统了。</p><p>这种做法虽然提高了效率， 但也为写入数据带来了安全问题， 因为如果计算机发生停机， 那么保存在内存缓冲区里面的写入数据将会丢失。</p><p>为此， 系统提供了 <code>fsync</code> 和 <code>fdatasync</code> 两个同步函数， 它们可以强制让操作系统立即将缓冲区中的数据写入到硬盘里面， 从而确保写入数据的安全性。 也就是说，Always和Everysec都调用 同步函数。</p></blockquote><p>比较一下三种方式：</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200911162720796.png" alt="image-20200911162720796" style="zoom:50%;" /><p>这时候，如果AOF开启，这明显有个问题，随着Redis系统的运行，AOF文件会越来越大，当发生系统宕机时，AOF恢复是很头痛的问题，所以Redis引入了<strong>AOF重写机制</strong>。</p><p>AOF重写机制，实际上就是把多个命令变成了一个命令，然后写入AOF文件，比如有6个命令对 test 这个key做了修改，AOF重写机制会选择最新的 test key的状态 写入AOF文件。</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200911163232926.png" alt="image-20200911163232926" style="zoom:50%;" /><p><strong>那Redis何时进行AOF重写？</strong></p><ol><li><p>手动触发，使用<code>BGREWRITEAOF</code></p></li><li><p>服务器自动进行重写</p><blockquote><p>服务器在AOF功能开启的情况下，会维持以下三个变量：</p><ol><li>记录当前AOF文件大小的变量<code>aof_current_size</code></li><li>记录最后一次AOF重写之后，AOF文件大小的变量<code>aof_rewrite_base_size</code></li><li>增长百分比变量<code>aof_rewrite_perc</code>。</li></ol><p>每次当<code>serverCron</code>（服务器周期性操作函数）函数执行时，它会检查以下条件是否全部满足，如果全部满足的话，就触发自动的AOF重写操作：</p><ol><li>没有BGSAVE命令（RDB持久化）/AOF持久化在执行</li><li>没有BGREWRITEAOF在进行</li><li>当前AOF文件大小要大于<code>server.aof_rewrite_min_size</code>（默认为1MB），或者在<code>redis.conf</code>配置了<code>auto-aof-rewrite-min-size</code>大小</li><li>当前AOF文件大小和最后一次重写后的大小之间的比率等于或者大于指定的增长百分比（在配置文件设置了<code>auto-aof-rewrite-percentage</code>参数，不设置默认为100%）</li></ol><p>如果前面三个条件都满足，并且当前AOF文件大小比最后一次AOF重写时的大小要大于指定的百分比，那么触发自动AOF重写</p></blockquote></li></ol><p><strong>AOF重写是否会阻塞主线程处理请求的命令？</strong></p><p>答案是不会阻塞主线程，由主线程fork出子线程完成 AOF的重写。</p><p>每次执行AOF重写时，主线程会fork出 <code>bgrewriteaof</code> 线程（注意，由于是fork当内存数据较多时，虽然不会拷贝父进程的内存数据，但是会拷贝父进程的空间内存页表，我们可以在 Info stats 统计中查询 latestforkusec 指标获取最近一次 fork 操作耗时，单位微秒），此时  <code>bgrewriteaof</code> 线程会共享主线程的内存数据，内存数据时最新的，那么现在子线程就可以生产一个 AOF重写日志（<strong>此时访问父进程的数据，是把全部内存数据都生产AOF重写日志吗？</strong>）</p><p>此时，有个问题，主线程还可以继续处理请求，可能主线程会更新内存中的数据，所以还需要依赖另外一个日志来处理 主线程更新后的数据：这时候还会生产主线程操作的AOF重写日志，待主线程完成操作后，再将子线程的AOF重写日志与主线程的重写日志合并。</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200911165649730.png" alt="image-20200911165649730" style="zoom:50%;" />]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt; Redis有两种数据持久化的方式，他们都有各自的特点，写下AOF持久化的总结。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>一次团队内的产品技术分享</title>
    <link href="https://frank0.top/2020/09/10/%E4%B8%80%E6%AC%A1%E5%9B%A2%E9%98%9F%E5%86%85%E7%9A%84%E4%BA%A7%E5%93%81%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/"/>
    <id>https://frank0.top/2020/09/10/%E4%B8%80%E6%AC%A1%E5%9B%A2%E9%98%9F%E5%86%85%E7%9A%84%E4%BA%A7%E5%93%81%E6%8A%80%E6%9C%AF%E5%88%86%E4%BA%AB/</id>
    <published>2020-09-10T08:18:44.000Z</published>
    <updated>2020-09-10T08:57:35.205Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>记录：一次分享PPT制作</p></blockquote><a id="more"></a><h4 id="利用脑图整理大纲"><a href="#利用脑图整理大纲" class="headerlink" title="利用脑图整理大纲"></a>利用脑图整理大纲</h4><p>这几天需要给团队做一次产品技术分享，主要是分享一下我们团队做的一个产品《XXX营销系统》，这个产品是一个很常规的产品，可以满足大多数营销场景。</p><p>为了做这个PPT 我很是苦恼，不知道从何下手也不知道如何进行制定演讲内容，内容与内容之间如何进行衔接，最后我决定先列出要讲的大纲，然后分别制定好每个PPT需要演讲的内容，然后才是PPT的制作，对于没有艺术功底的我来说也是一项繁重的任务。</p><p>首先，列出需要演讲的内容，我使用脑图来梳理我需要演讲的内容：</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200910160821116-9727644.png" alt="image-20200910160821116" style="zoom:50%;" /><p>使用脑图很方便的列出我需要讲的大纲，有了大纲我才可以继续梳理，每个大纲需要将什么内容；同时我也会思考每个点如何进行承上启下。有了大概，我继续细化每个点需要讲的内容，由于涉及公司内容，这里就不贴了。</p><h4 id="选择合适图形与图表"><a href="#选择合适图形与图表" class="headerlink" title="选择合适图形与图表"></a>选择合适图形与图表</h4><p>大纲差不多整理完了，那就可以进行下一步了，选择一个具有科技股的模板，一般我优先选择蓝色的。</p><p>推荐网址：<a href="http://www.ypppt.com/" target="_blank" rel="noopener">http://www.ypppt.com/</a> </p><p>里面有个模块不错：<a href="http://www.ypppt.com/tubiao/" target="_blank" rel="noopener">http://www.ypppt.com/tubiao/</a>  图标模块，当我不知道如何展示一个内容的时候，我会去这里找灵感。</p><p>加上自身的逻辑，很容易找到图表的展示方式。</p><p>在制作的过程中，有些我们需要一些图标，最好选择矢量图，推荐网址：<a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2" target="_blank" rel="noopener">https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2</a> 阿里巴巴的图标搜索</p><h4 id="克服语言障碍进行试讲"><a href="#克服语言障碍进行试讲" class="headerlink" title="克服语言障碍进行试讲"></a>克服语言障碍进行试讲</h4><p>PPT 制作完成之后，我自己给领导进行了一次试讲，领导会点评，有个好方法是全程录音，因为事后可能需要总结和修改，你通过录音能够复盘，哪里讲的不好，哪里需要进行着重渲染，上下文怎么衔接，是否有遗漏的地方，都可以通过复盘来找出来。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;记录：一次分享PPT制作&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis基础2_为什么选择单线程</title>
    <link href="https://frank0.top/2020/08/21/Redis%E5%9F%BA%E7%A1%802-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B/"/>
    <id>https://frank0.top/2020/08/21/Redis%E5%9F%BA%E7%A1%802-%E4%B8%BA%E4%BB%80%E4%B9%88%E9%80%89%E6%8B%A9%E5%8D%95%E7%BA%BF%E7%A8%8B/</id>
    <published>2020-08-21T09:29:28.000Z</published>
    <updated>2020-08-21T09:38:02.509Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近重温redis基础知识的学习随笔，随便写写</p></blockquote><a id="more"></a><p>我们都知道Redis是单线程模型的内存KV数据库（网络IO与键值对读写单线程），可是为啥Redis选择了单线程，现在大多数服务器都是64G+12核心左右，为什么Redis选择了单线程？</p><h4 id="多线程带来什么问题？"><a href="#多线程带来什么问题？" class="headerlink" title="多线程带来什么问题？"></a>多线程带来什么问题？</h4><p>平常做Java开发,都涉及到多线程,直观的感觉,多线程比单线程快,其实当线程数多到一定程度,执行效率可能还没有单线程快。</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/20200820161046.png" style="zoom:50%;" /><p>多线程也分应用场景</p><p>计算型操作，多线程用起来相对比较高效</p><p>IO型操作，多线程用起来提升不了多大性能</p><h5 id="线程模型设计比单线程模型复杂"><a href="#线程模型设计比单线程模型复杂" class="headerlink" title="线程模型设计比单线程模型复杂"></a>线程模型设计比单线程模型复杂</h5><p>多线程模型涉及到共享数据，锁的粒度大小，如果设置的不合理都会导致效率不高；</p><h5 id="多线程线程切换带来的成本"><a href="#多线程线程切换带来的成本" class="headerlink" title="多线程线程切换带来的成本"></a>多线程线程切换带来的成本</h5><p>多线程切换时有一定的性能损耗，即使不一般不大，但是也会有一定影响</p><h5 id="不易调试与维护"><a href="#不易调试与维护" class="headerlink" title="不易调试与维护"></a>不易调试与维护</h5><p>多线程模型，引入了并发，多线程代码降低了代码的可读性与可维护性</p><h4 id="Redis单线程为什么快？"><a href="#Redis单线程为什么快？" class="headerlink" title="Redis单线程为什么快？"></a>Redis单线程为什么快？</h4><h5 id="Redis是内存数据库"><a href="#Redis是内存数据库" class="headerlink" title="Redis是内存数据库"></a>Redis是内存数据库</h5><p>大部分Redis操作都是在内存上完成</p><h5 id="Redis优秀的存储数据结构"><a href="#Redis优秀的存储数据结构" class="headerlink" title="Redis优秀的存储数据结构"></a>Redis优秀的存储数据结构</h5><p>Redis的内部的数据结构时间复杂度大多是 O(logN) O(1)，范围扫描等时间复杂度是O(N)</p><h5 id="Redis使用了多路复用的IO模型"><a href="#Redis使用了多路复用的IO模型" class="headerlink" title="Redis使用了多路复用的IO模型"></a>Redis使用了多路复用的IO模型</h5><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/image-20200820165211392.png" alt="image-20200820165211392" style="zoom:50%;" /><p>多路IO复用极大的提高了Redis的IO效率，可以看到图中，连接绑定上之后，会有多种事件，所有的事件都存放到了Redis一个队列中，事件出队，Redis使用一个线程来处理具体的事件。</p><p>当然，任何架构都不是完美的，可以从上图的IO模型看到，这个队列是Redis的性能瓶颈。</p><ol><li>队列中的任何事件，如果处理事件（请求）耗时，则整个Redis服务会受到影响</li><li>Big Key 会损耗内存</li><li>复杂度高的命令，对redis影响比较大 O(N),如：keys *  SORT等</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近重温redis基础知识的学习随笔，随便写写&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Redis基础学习1</title>
    <link href="https://frank0.top/2020/08/17/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/"/>
    <id>https://frank0.top/2020/08/17/Redis%E5%9F%BA%E7%A1%80%E5%AD%A6%E4%B9%A01/</id>
    <published>2020-08-17T08:36:49.000Z</published>
    <updated>2020-08-17T08:49:30.106Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>最近重温redis基础知识的学习随笔，随便写写</p></blockquote><a id="more"></a><p>redis本质上是一个hash表，复杂度为O(1);</p><p>Key 一般是个String类型，Value可以包含多种类型:String、List、Hash、SortedSet、Set；github上有人对redis3.0做了注释，有空可以看看源码：<a href="https://github.com/frankan0/redis-3.0-annotated/blob/unstable/src/dict.h" target="_blank" rel="noopener">redis3.0源码注释</a></p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/20200817154827-20200817164744005.png" style="zoom:50%;" /><p>具体定义的代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;  <span class="comment">//type和privdata是针对不同类型的键值对，为创建多态字典而设置的</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];  <span class="comment">//两个hashtable，用于存储和rehash</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;  <span class="comment">//如果没有进行rehash，则值为-1，否则，rehash表示rehash进行到的索引位置</span></span><br><span class="line">    unsigning <span class="keyword">long</span> iterators;</span><br><span class="line">&#125;dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">//哈希表定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line">    dictEntry **table;  <span class="comment">//指针，指向一个哈希桶bucket</span></span><br><span class="line">    unsigning <span class="keyword">long</span> <span class="built_in">size</span>;  <span class="comment">//哈希表的大小</span></span><br><span class="line">    unsigning <span class="keyword">long</span> sizemask;  <span class="comment">//总是size-1，这个值和哈希值一起决定元素应该定位到桶中的什么位置</span></span><br><span class="line">    unsigning <span class="keyword">long</span> used;  <span class="comment">//已使用的桶数量</span></span><br><span class="line">&#125;dictht;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体键值对定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span>&#123;</span></span><br><span class="line">    <span class="keyword">void</span> *key;   <span class="comment">//键值</span></span><br><span class="line">    <span class="keyword">union</span>&#123;</span><br><span class="line">        <span class="keyword">void</span> *val;  <span class="comment">//value值</span></span><br><span class="line">        unint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125;v;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span>  <span class="comment">//指向下一个键值对的指针，用于解决哈希冲突问题</span></span><br><span class="line">&#125;dictEntry;</span><br></pre></td></tr></table></figure><p>在这个大的hash表中，实际上Value都存储的是指针；</p><p>本质上是大的Hash表，就有个通用的问题：（类似Java的hashMap）</p><ol><li>如何解决hash冲突</li><li>何时进行扩容</li><li>如何扩容Hash表</li></ol><h4 id="如果解决hash冲突？"><a href="#如果解决hash冲突？" class="headerlink" title="如果解决hash冲突？"></a>如果解决hash冲突？</h4><p>跟Java的hashMap一样，redis采用链式hash解决hash冲突，如果存在相同的KEY，则在hash桶中，增加一个节点，如图：</p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/20200817155047-20200817164810911.png" style="zoom:50%;" /><p>当数据越来越大，随之而来的是冲突越来越多，这个链表则会越来越长，此时，redis会进行hash桶的扩容，俗称“rehash”;</p><p>Java里面的HashMap也有这个操作，不过，Java8在内部做了一个优化，当冲突链表超过8个时，会转化成红黑树，有个”树化“的过程。</p><h4 id="何时进行扩容？"><a href="#何时进行扩容？" class="headerlink" title="何时进行扩容？"></a>何时进行扩容？</h4><p>Java里面有个负载因子，默认为0.75，当大于这个负载因子时，hashMap就进行扩容。</p><p>负载因子 = 哈希表保存的KEY的数量 / 哈希表的大小</p><p>redis中，这个跟hashMap类似，超过阈值时进行扩容</p><h4 id="如何扩容hash表？"><a href="#如何扩容hash表？" class="headerlink" title="如何扩容hash表？"></a>如何扩容hash表？</h4><p>Java中的HashMap扩容是直接进行复制。而redis中，则是”渐进式扩容”可以看到上面 字典的定义：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//字典定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>  <span class="title">dict</span>&#123;</span></span><br><span class="line">    dictType *type;  <span class="comment">//type和privdata是针对不同类型的键值对，为创建多态字典而设置的</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line">    dictht ht[<span class="number">2</span>];  <span class="comment">//两个hashtable，用于存储和rehash</span></span><br><span class="line">    <span class="keyword">long</span> rehashidx;  <span class="comment">//如果没有进行rehash，则值为-1，否则，rehash表示rehash进行到的索引位置</span></span><br><span class="line">    unsigning <span class="keyword">long</span> iterators;</span><br><span class="line">&#125;dict;</span><br></pre></td></tr></table></figure><p>定义了两个hashtable，一个hashtable正常处理业务逻辑，另外一个就是在rehash时，需要使用的hashtable。</p><ul><li><p>处理请求时进行rehash的搬运操作</p><p>每次请求时，如果正在rehash操作，则本次请求中，将本次查询的hash槽进行搬运。</p></li><li><p>redis定时进行rehash的搬运操作</p><p>定时的进行rehash操作，这个只有在服务器空闲时进行，且每次只操作100个槽，每次不超过1ms</p></li></ul><p>这样redis就完成了，渐进式的rehash操作。</p><p>redis的字典表跟Java的hashMap结构还是有很多相似之处，有时候可以放在一个维度上进行对比，加深理解，建立网状的知识结构，后面你就会发现很多其实是相同的，比如RPC，消息队列，数据库有很多地方都是相同的，怎么进行通信，如果存储数据，怎么实现两阶段提交等等</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;最近重温redis基础知识的学习随笔，随便写写&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="redis hash" scheme="https://frank0.top/tags/redis-hash/"/>
    
  </entry>
  
  <entry>
    <title>socks5协议与客户端简单实现</title>
    <link href="https://frank0.top/2020/05/29/socks5%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/"/>
    <id>https://frank0.top/2020/05/29/socks5%E5%8D%8F%E8%AE%AE%E4%B8%8E%E5%AE%A2%E6%88%B7%E7%AB%AF%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-05-29T09:40:05.000Z</published>
    <updated>2020-05-29T09:42:53.159Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>在国内，如果想要访问google等被封锁的网站，我们想要翻墙，一直以来都是自己搭建翻墙软件，有一些一键部署脚本，今天受一个朋友委托想要做手机端的代理软件，所以就研究了一下这个协议；为以后开发android的代理软件（并非FQ软件）打下基础。</p></blockquote><a id="more"></a><p>首先，socks5协议并非网络编程中的sockets，socks是一种协议最新版本应该是socks5;而sockets是一种网络编程方法,是一种工具，就像打电话，socks5可以理解为某种交流语言，而sockets是电话。</p><p>socks协议是会话层协议，这就表明，他可以无视会话层之上的协议，如http等应用层协议,也就是说可以代理HTTP等上层协议；由于是会话层协议，所以他依赖TCP/IP协议。</p><p>著名的shadowsocks就是基于此协议，但是shadowsocks提供了丰富的加密功能，而<code>socks5是不具备加密功能的</code>。</p><p>socks协议有很多版本，如socks4,socks4a,socks5 最新版本是socks5,提供了UDP代理，认证，IPV6功能。</p><p>这次主要研究socks5；</p><p>需要注意的是，当客户端与服务器端<code>建立TCP连接之后</code>才会根据<code>socks5协议进行握手</code>。</p><p>socks5协议内容(<code>以字节为单位</code>):</p><h5 id="客户端请求握手"><a href="#客户端请求握手" class="headerlink" title="客户端请求握手"></a>客户端请求握手</h5><p>建立连接之后，客户端发出握手请求：</p><table><thead><tr><th>VER</th><th>NMETHODS</th><th>METHODS</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>1-255</td></tr></tbody></table><ul><li><p>VER是SOCKS版本，这里应该是0x05</p></li><li><p>NMETHODS是METHODS部分的长度</p></li><li><p>METHODS是客户端支持的认证方式列表，每个方法占1字节。当前的定义是：</p><ul><li>0x00 不需要认证 (常用)</li><li>0x01 GSSAPI</li><li>0x02 用户名、密码认证 (常用)</li><li>0x03 - 0x7F由IANA分配（保留）</li><li>0x80 - 0xFE为私人方法保留</li><li>0xFF 无可接受的方法</li></ul></li></ul><h5 id="服务端回应握手信息"><a href="#服务端回应握手信息" class="headerlink" title="服务端回应握手信息"></a>服务端回应握手信息</h5><table><thead><tr><th>VER</th><th>METHOD</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr></tbody></table><ul><li>VER是SOCKS版本，这里应该是0x05；</li><li>METHOD是服务端选中的方法。如果返回0xFF表示没有一个认证方法被选中，客户端需要关闭连接。</li></ul><p>如果服务端允许直接访问或者用户名密码认证访问,Method 应该是0x00或者是0x02</p><h5 id="客户端发送认证请求"><a href="#客户端发送认证请求" class="headerlink" title="客户端发送认证请求"></a>客户端发送认证请求</h5><table><thead><tr><th>鉴定协议版本</th><th>用户名长度</th><th>用户名</th><th>密码长度</th><th>密码</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>动态</td><td>1</td><td>动态</td></tr></tbody></table><p>协议版本目前固定为 0x01</p><p>这里必须要注意一下，用户名长度与密码长度；</p><p>一般用户名和密码都是字符串，这里需要把 String-&gt;16进制字符串-&gt;byte数组 ;这个长度就是数组的长度。</p><p>用户名与密码都传入这个byte数组就行。</p><p>为什么是16进制？16进制比较好认。</p><h5 id="服务器认证应答"><a href="#服务器认证应答" class="headerlink" title="服务器认证应答"></a>服务器认证应答</h5><table><thead><tr><th>鉴定协议版本</th><th>鉴定状态</th></tr></thead><tbody><tr><td>1</td><td>1</td></tr></tbody></table><p>协议版本目前固定为 0x01</p><p>其中鉴定状态 0x00 表示成功，0x01 表示失败。</p><p>认证成功之后，客户端就可以发送请求信息，比如 客户端需要访问baidu.com就需要发送请求信心，让服务端去请求baidu.com</p><h5 id="客户端请求命令"><a href="#客户端请求命令" class="headerlink" title="客户端请求命令"></a>客户端请求命令</h5><table><thead><tr><th>VER</th><th>CMD</th><th>RSV</th><th>ATYP</th><th>DST.ADDR</th><th>DST.PORT</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0x00</td><td>1</td><td>动态</td><td>2</td></tr></tbody></table><ul><li><p>VER是SOCKS版本，这里应该是0x05；</p></li><li><p>CMD是SOCK的命令码</p><ul><li>0x01表示CONNECT请求</li><li>0x02表示BIND请求</li><li>0x03表示UDP转发</li></ul></li><li><p>RSV 0x00，保留</p></li><li><p>ATYP DST.ADDR类型</p><ul><li>0x01 IPv4地址，DST.ADDR部分4字节长度</li><li>0x03 域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾。</li><li>0x04 IPv6地址，16个字节长度。</li></ul></li><li><p>DST.ADDR 目的地址</p></li><li><p>DST.PORT 网络字节序表示的目的端口</p></li></ul><p>这里也需要注意一下，socks5是支持域名解析的，所以一般我们请求的时候直接使用域名发出请求。</p><p>服务端进行请求是，如果是IP则直接进行IP进行请求，如果是域名需要进行解析才能请求。</p><p>DST.ADDR这个字段一般是域名字符串的byte数组。</p><h5 id="服务端请求命令应答"><a href="#服务端请求命令应答" class="headerlink" title="服务端请求命令应答"></a>服务端请求命令应答</h5><table><thead><tr><th>VER</th><th>REP</th><th>RSV</th><th>ATYP</th><th>BND.ADDR</th><th>BND.PORT</th></tr></thead><tbody><tr><td>1</td><td>1</td><td>0x00</td><td>1</td><td>动态</td><td>2</td></tr></tbody></table><ul><li><p>VER是SOCKS版本，这里应该是0x05；</p></li><li><p>REP应答字段</p><ul><li>0x00表示成功</li><li>0x01普通SOCKS服务器连接失败</li><li>0x02现有规则不允许连接</li><li>0x03网络不可达</li><li>0x04主机不可达</li><li>0x05连接被拒</li><li>0x06 TTL超时</li><li>0x07不支持的命令</li><li>0x08不支持的地址类型</li><li>0x09 - 0xFF未定义</li></ul></li><li><p>RSV 0x00，保留</p></li><li><p>ATYP BND.ADDR类型</p><ul><li>0x01 IPv4地址，DST.ADDR部分4字节长度</li><li>0x03域名，DST.ADDR部分第一个字节为域名长度，DST.ADDR剩余的内容为域名，没有\0结尾。</li><li>0x04 IPv6地址，16个字节长度。</li></ul></li><li><p>BND.ADDR 服务器绑定的地址</p></li><li><p>BND.PORT 网络字节序表示的服务器绑定的端口</p></li></ul><p>其实跟请求一样，我们需要关注的REP应答字段，可以打印日志，判断是否连接成功。</p><hr><p>以上算是握手成功，之后就是数据正常传输，比如客户端访问baidu.com的HTTP数据包，发送到socks服务器，socks服务器访问之后，把响应如实返回给客户端，这就是代理。</p><h5 id="最后在来个实例（部分Java代码）"><a href="#最后在来个实例（部分Java代码）" class="headerlink" title="最后在来个实例（部分Java代码）"></a>最后在来个实例（部分Java代码）</h5><p>请求握手，协议版本05,客户端只支持用户名和密码认证</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">buffer.clear();</span><br><span class="line">buffer.put((<span class="keyword">byte</span>)<span class="number">0x05</span>);</span><br><span class="line">buffer.put((<span class="keyword">byte</span>)<span class="number">0x01</span>);</span><br><span class="line">buffer.put(<span class="keyword">new</span> <span class="keyword">byte</span>[]&#123;<span class="number">0x02</span>&#125;);</span><br><span class="line">buffer.flip();</span><br><span class="line"><span class="keyword">if</span>(write(buffer, <span class="keyword">true</span>))&#123;</span><br><span class="line">  SOCKS_PHASE = <span class="number">1</span>;</span><br><span class="line">  beginReceive();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端响应：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9gatugn8j314g044dgj.jpg" alt="image-20200529173135516"></p><p>客户端构造认证请求：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">byte</span>[] arrayOfByte1 = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">4</span>];</span><br><span class="line">   <span class="keyword">byte</span>[] arrayOfByte = <span class="keyword">this</span>.m_Config.Username.getBytes();</span><br><span class="line">   <span class="keyword">byte</span>[] arrayOfByte2 = <span class="keyword">this</span>.m_Config.Password.getBytes();</span><br><span class="line">   <span class="keyword">int</span> i = <span class="keyword">this</span>.m_Config.Username.length();</span><br><span class="line">   <span class="keyword">int</span> j = <span class="keyword">this</span>.m_Config.Password.length();</span><br><span class="line"><span class="comment">//用户名与密码</span></span><br><span class="line">   arrayOfByte = StringUtil.getByteArrayByHex(<span class="keyword">this</span>.m_Config.Username);</span><br><span class="line">   arrayOfByte2 = StringUtil.getByteArrayByHex(<span class="keyword">this</span>.m_Config.Password);</span><br><span class="line">   <span class="keyword">int</span> k = i+<span class="number">3</span>;</span><br><span class="line">   arrayOfByte1 = <span class="keyword">new</span> <span class="keyword">byte</span>[k+j];</span><br><span class="line">   arrayOfByte1[<span class="number">0</span>] = <span class="number">0x01</span>;</span><br><span class="line">   arrayOfByte1[<span class="number">1</span>] = IntToByte(i)[<span class="number">3</span>];</span><br><span class="line">   System.arraycopy(arrayOfByte, <span class="number">0</span>, arrayOfByte1, <span class="number">2</span>, i);</span><br><span class="line">   arrayOfByte1[i + <span class="number">2</span>] = IntToByte(j)[<span class="number">3</span>];</span><br><span class="line">   System.arraycopy(arrayOfByte2, <span class="number">0</span>, arrayOfByte1, k, j);</span><br><span class="line">   paramByteBuffer.clear();</span><br><span class="line">   paramByteBuffer.put(arrayOfByte1);</span><br><span class="line">   paramByteBuffer.flip();</span><br></pre></td></tr></table></figure><p>服务端响应：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gf9gbr9g4aj316s064wfd.jpg" alt="image-20200529173231196"></p><p>构造请求命令数据包：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//校验认证是否成功？</span></span><br><span class="line"><span class="keyword">if</span> (data.length != <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">if</span> (data[<span class="number">0</span>]==<span class="number">0x01</span> &amp;&amp; data[<span class="number">1</span>] ==<span class="number">0x00</span>)&#123;</span><br><span class="line">  System.out.println(<span class="string">"认证成功，继续"</span>);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">  System.out.println(<span class="string">"认证失败"</span>);</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//组装命令过程数据</span></span><br><span class="line"><span class="keyword">byte</span>[] arrayOfByte1 = <span class="keyword">this</span>.m_DestAddress.getHostName().getBytes();</span><br><span class="line"><span class="keyword">byte</span>[] portArrayOfByte = unsignedShortToByte2((<span class="keyword">short</span>)<span class="keyword">this</span>.m_DestAddress.getPort());</span><br><span class="line"><span class="keyword">byte</span>[] arrayOfByte2 = <span class="keyword">new</span> <span class="keyword">byte</span>[arrayOfByte1.length + <span class="number">5</span> + portArrayOfByte.length];</span><br><span class="line">arrayOfByte2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">arrayOfByte2[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">arrayOfByte2[<span class="number">2</span>] = <span class="number">0</span>;</span><br><span class="line">arrayOfByte2[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">arrayOfByte2[<span class="number">4</span>] = (<span class="keyword">byte</span>)arrayOfByte1.length;</span><br><span class="line">System.arraycopy(arrayOfByte1, <span class="number">0</span>, arrayOfByte2, <span class="number">5</span>, arrayOfByte1.length);</span><br><span class="line">System.arraycopy(portArrayOfByte, <span class="number">0</span>, arrayOfByte2, arrayOfByte1.length + <span class="number">5</span>, portArrayOfByte.length);</span><br><span class="line">paramByteBuffer.clear();</span><br><span class="line">paramByteBuffer.put(arrayOfByte2);</span><br><span class="line">paramByteBuffer.flip();</span><br></pre></td></tr></table></figure><p>服务端响应：</p><p><img src="https://frankblogimgs.oss-cn-beijing.aliyuncs.com/20200529173805.png" alt=""></p><p>可以看到服务器应答成功了；之后就是正常的数据传输了。</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;在国内，如果想要访问google等被封锁的网站，我们想要翻墙，一直以来都是自己搭建翻墙软件，有一些一键部署脚本，今天受一个朋友委托想要做手机端的代理软件，所以就研究了一下这个协议；为以后开发android的代理软件（并非FQ软件）打下基础。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
      <category term="android socks5 proxy" scheme="https://frank0.top/tags/android-socks5-proxy/"/>
    
  </entry>
  
  <entry>
    <title>商业的本质与互联网略读</title>
    <link href="https://frank0.top/2020/05/07/%E5%95%86%E4%B8%9A%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E7%95%A5%E8%AF%BB/"/>
    <id>https://frank0.top/2020/05/07/%E5%95%86%E4%B8%9A%E7%9A%84%E6%9C%AC%E8%B4%A8%E4%B8%8E%E4%BA%92%E8%81%94%E7%BD%91%E7%95%A5%E8%AF%BB/</id>
    <published>2020-05-07T03:32:03.000Z</published>
    <updated>2020-05-08T05:25:07.547Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>本书讲了互联网的历史，一些经济规律与互联网的关系。看似很平常的事情，但是给我耳目一新的感觉，因为之前根本就不知道这些专业名词，对于我这种经济学小白来说，还是有益的。</p></blockquote><a id="more"></a><h4 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gekz3ohhluj31as0u0491.jpg" alt=""></p><h3 id="专业名词"><a href="#专业名词" class="headerlink" title="专业名词"></a>专业名词</h3><h4 id="梅特卡夫效应"><a href="#梅特卡夫效应" class="headerlink" title="梅特卡夫效应"></a>梅特卡夫效应</h4><p>网络具有独特的梅特卡夫效应。不限于互联网，电话网，铁路网也具有。</p><p>鉴于梅特卡夫效应是理解各类互联网商业模式的关键，我们借助一个简单的概念模型，推导出梅特卡夫效应。与成本结构决定的规模效应和协同效应不同，梅特卡夫效应源自网络用户之间的互动，这个概念模型可以清晰地展示这种互动。让我们设想一家电话公司投资9元，架设a、b两人之间的一条电话线（如图4-1中的粗实线所示），两人每月的通话费为10元，公司的利润为1元。我们在这里略去了除投资之外的所有成本，以便尽可能地保持分析的简洁。如果公司想扩大经营规模和经营收入，决定增加b和c之间的一条线，b和c的通话将给公司带来10元的收入。公司的收入翻番至20元，但成本也翻番到18元，利润2元，都是同幅度线性增长。如果公司想进一步扩大规模，是否要投资再建新线呢？不一定。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejpoq7nzcj30eu0bejsl.jpg" alt=""></p><p>公司这时发现，可以利用两条线路实现a、b、c三点之间的通信，而不必架设a到c的线路（图4-1中的细线）。公司只需在节点b安装一台电话交换机，当a和b通话时，交换机阻断来自c的呼叫，以避免干扰a和b，当a和c的讲话结束后，交换机再连接c和a。公司以两条线路的成本18元，产生3倍也就是30元的收入，如果忽略交换机的成本，利润为30-18=12元。换句话说，当节点数从2增加到3，也就是增加了50%，收入和利润分别涨了3倍和12倍！感受到网络的魔力了吧？在经济学中，我们称这一现象为“边际收益递增”，意思是每一新增节点的收益不断上升。即使电话交换机是有成本的，也比建一条a到c的线路要小得多，不会因此颠覆边际收益递增的结论。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejppicojaj30fe0cggns.jpg" alt=""></p><p>让我们继续这个脑力游戏的推理，电话公司再架设一条从c到d的线路，三条线可以使6对客户通话，即ab、ac、ad、bc、bd、cd（见上图），公司的收入增长(60-30)/30=100%，而成本只增加了(27-18)/18=50%，边际收益递增的特征就是收入上涨得比成本更快。推而广之，如果有n-1条线连接第n个客户呢？在这n个人当中，两两通话的可能性有多少？这是一个组合问题，由中学数学知识可知，有n(n-1)/2种可能。如果n=10则有45对节点通话，当n=100时，两人组合的数目达到4950，即电话线路增加10倍，而话费收入增加(4950-45)/45=110倍！电话公司的收入或者网络的价值随用户数呈指数增长，这个关系被称为梅特卡夫定理，用公式表达如下</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejpr9j6mcj306802ajrb.jpg" alt=""></p><p>公式中，VM代表具有梅特卡夫效应的网络价值，k1是个常数，n是网络节点或网络用户数。读者需要注意，梅特卡夫定律不是物理学意义上的精确定律，而是从大量观察中得出的统计学意义上的近似公式。2015年，中国科学院的三位研究人员分析了脸书和腾讯的实际数据，证明梅特卡夫定律是成立的，互联网公司的市场价值的确与网络节点数的平方成正比。</p><p>有意思的是，梅特卡夫从对互联网的观察中得出以他命名的定律，<strong>但并不是所有的互联网公司都具有梅特卡夫效应</strong>。这个强大的效应产生于节点间活跃的互动，对于某一类网络，互动仅发生在不同类别的用户之间，例如淘宝和天猫平台上，互动和交易仅在供应商和消费者之间进行，供应商和供应商之间鲜有交易，消费者和消费者老死不相往来。这类互联网平台的价值源于供应方和需求方的相互吸引和相互促进，遵循学术界的惯例，我们称之为<strong>双边市场效应。</strong></p><h4 id="双边市场效应"><a href="#双边市场效应" class="headerlink" title="双边市场效应"></a>双边市场效应</h4><p>我们定义双边市场效应为：<strong>不同类型用户之间正反馈交互所创造的价值</strong>。请注意“不同类型用户”的限定，这意味着<strong>同类用户之间没有互动，双边市场效应因此弱于梅特卡夫效应</strong>。<strong>优步（Uber）等出租车服务平台具有很强的双边市场效应，打车的需求越高，司机的预期收入越高，就有更多的司机加入优步网约车的行列</strong>。另一方面，司机和车辆多，打车就越是方便，并且随着供给的增加，价格会越来越低，于是会吸引更多的消费者。和梅特卡夫效应一样，双边市场效应不是互联网所特有的，甚至不是网络所特有的。实际上，任何一个市场比如浙江义乌小商品市场都可以看到供给和需求的相互促进。采购者愿意去义乌，因为那里有琳琅满目的小商品可供选择。生产厂家愿意在义乌设点，因为那里有来自全国甚至全世界的众多采购者。就供给和需求之间的良性循环而言，义乌和优步没有本质的区别，只不过前者的规模受到物理空间的限制，而后者在互联网虚拟空间中有着似乎是无限的潜力。</p><p>区分双边市场效应和梅特卡夫效应是重要的，在双边市场中，并非任意两个节点都可能产生交互。在大多数情况下，同类用户无交互，如图4-3所示，约车平台上的司机b1和b2之间没有沟通，打车人c1和c2彼此素昧平生。4个节点只有4对可能的互动，即b1c1、b1c2、b2c1、b2c2，而图4-2同样4个节点有6对可能的互动。对比图4-2和图4-3，我们可以清晰地从网络结构以及交互的丰富程度上看出梅特卡夫效应和双边市场效应的差别。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejpuudi14j30ry0i00xx.jpg" alt=""></p><h4 id="规模效应"><a href="#规模效应" class="headerlink" title="规模效应"></a>规模效应</h4><p>规模效益取决于<strong>成本结构</strong>。企业的总成本由<strong>固定成本</strong>和<strong>可变成本</strong>组成，固定成本的比重越大，规模经济效益越好。什么是固定成本？顾名思义，不随产出数量变化的成本，例如厂房、设备、办公楼、电脑信息系统；可变成本则与产量高度相关，像原材料、能源和人工费用，等等。</p><p>为了进一步理解规模效应和成本结构的关系，我们构造一个简单的数值案例。假设一家企业的固定成本为1万元，不妨想象为价值1万元的一台冲压机床，一年折旧完毕，摊入成本。工人操作这台设备将2元一件的薄钢板压制成汤匙，为分析的方便，不考虑材料之外的可变成本如人工、能源等。当产量为1000时，总成本等于固定成本加可变成本即材料费，（10000+2×1000）=12000元，单位成本为12000/1000=12元。如果产量增加到3000，单位成本降到（10000+2×3000）/3000=5.3元。当产量为5000时，单位成本更低，只有（10000+2×5000）/5000=4元。单位成本随产量的增加而递减，在汤匙售价不变的情况下，销售每一汤匙的利润（价格减成本）随产量的增加而上升，这就是规模经济效益。从这个例子可以看出，规模经济效益来自分摊到每单位产品上的固定成本的下降。不难验证，固定成本占总成本的比重越高，规模经济效益越好。假如固定成本等于2万元，可变成本仍是每件2元，产量为1000时，平均成本是22元；当产量增加到5000时，平均成本为6元，单位成本降低了12元。在前面的数值案例中，固定成本为1万元时，产量从1000增加到5000，平均成本只降低了12-4=8元。</p><p><strong>需要注意的是，固定成本并非一成不变，经济学教科书经常有这样的表述：固定成本短期不变，长期可变。</strong>这个表述不是很准确，影响固定成本的主要不是时间，而是产量和设计产能。如果一条手机生产线的设计能力是一年10万部，当产量超过10万，比如说达到11万时，厂家就要投资另建一条线，固定成本因此而陡增。互联网公司也是这样，在流量和数据量大到现有数据中心无法承接时，必须投建新机房，购买更多服务器。画成图像的话，横轴是产量，固定成本是一条阶梯形上升的折线。对比之下，餐饮、零售等行业不需要多少固定资产投资，房屋店面都不必自己拥有，租用即可，因而对经营规模的要求比较低，小餐馆、小商店遍地开花，小本生意也可赢利。</p><p>规模不可怕，可怕的是同质化，是缺乏创新的能力。很典型的例子，阿里的来往、腾讯的微信、阿里的钉钉</p><h4 id="协同效应"><a href="#协同效应" class="headerlink" title="协同效应"></a>协同效应</h4><p>与规模效应类似又不尽相同，区别在于前者和单一产品的数量相关，而后者取决于品种的丰富程度。</p><p>腾讯建设和维护微信成本是固定的，微信平台上承载的服务越多，电商、广告、游戏、支付、理财、银行等，各项服务的供应商越多，腾讯公司的效益就越好。苹果公司的协同效应体现在数以百万计的App上，新增一个App，比如说爱奇艺，并不消耗苹果的任何资源，却给苹果带来新的收入，即爱奇艺支付的平台使用费。当然，羊毛出在羊身上，最终埋单的还是爱奇艺的用户，消费者成为付费会员后，才能下载它的一些音像产品。免费的音乐和视频虽然也有，但消费者必须先看一两分钟烦人的广告，做广告的商家构成爱奇艺的另一重要收入来源。商家之间的协同也不可忽视，百货大楼里热销的新款跑步鞋有可能带动邻近帽子店的销售。在京东上买了手电，顺便再下单订两节电池。商品种类越是齐全，客户购买的便利性体验越好，百货公司或电商的收入也就越高。</p><p>与双边市场效应不同，这个协同效应是品类的丰富。双边市场效应是两边的规模增加而不是品类增加。</p><h3 id="案例分析"><a href="#案例分析" class="headerlink" title="案例分析"></a>案例分析</h3><h4 id="淘宝-天猫"><a href="#淘宝-天猫" class="headerlink" title="淘宝/天猫"></a>淘宝/天猫</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejq2zzk21j30q40n0dn3.jpg" alt=""></p><p>是一个交易平台，和电商有本质区别；盈利模式是收取交易手续费。</p><p>具有双边市场效应，具有规模效应与协同效应，不具有梅特卡夫效应，</p><h4 id="京东-亚马逊"><a href="#京东-亚马逊" class="headerlink" title="京东/亚马逊"></a>京东/亚马逊</h4><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejq2hgfryj30v40kmn1b.jpg" alt=""></p><p>是一个电商，依靠赚取差价获利。</p><p>不具有梅特卡夫效应，不具有双边市场效应，具有规模效应与协同效应</p><h4 id="共享经济"><a href="#共享经济" class="headerlink" title="共享经济"></a>共享经济</h4><p>本质上只是使用了互联网工具的出租公司。</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1gejq4lawnqj30zs0eqtbw.jpg" alt=""></p><h4 id="图书信息"><a href="#图书信息" class="headerlink" title="图书信息"></a>图书信息</h4><p>《信息规则：网络经济的战略方向》</p><p>《长尾理论》</p><p>《平台革命》</p>]]></content>
    
    <summary type="html">
    
      &lt;blockquote&gt;
&lt;p&gt;本书讲了互联网的历史，一些经济规律与互联网的关系。看似很平常的事情，但是给我耳目一新的感觉，因为之前根本就不知道这些专业名词，对于我这种经济学小白来说，还是有益的。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>Thymeleaf-Layout引起的内存泄露</title>
    <link href="https://frank0.top/2020/04/22/Thymeleaf-Layout-GC-Error/"/>
    <id>https://frank0.top/2020/04/22/Thymeleaf-Layout-GC-Error/</id>
    <published>2020-04-22T04:17:43.000Z</published>
    <updated>2020-04-22T10:58:58.198Z</updated>
    
    <content type="html"><![CDATA[<p>最近线上维护的一个程序经过微服务化之后，出现了很多GC，而且内存被耗尽，小网站，不应该耗尽4G内存,调查了一下原因，原来是</p><a id="more"></a><p>服务器硬件信息：</p><p>SSD: 80 GB RAID-10<br>RAM: 4096 MB<br>CPU: 2x Intel Xeon</p><p>软件信息：</p><p>MySQL,Redis,JDK8,SpringBoot,Thymeleaf</p><p>JVM参数：<code>/opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.0.0.1-SNAPSHOT.jar --spring.profiles.active=online</code></p><p>用来跑了一些Java程序，运行一天之后，出现OOM异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br></pre></td></tr></table></figure><p>GC overhead limit exceeded异常，GOOGLE一番：</p><p>The <em>java.lang.OutOfMemoryError: GC overhead limit exceeded</em> error is the JVM’s way of signalling that your application spends too much time doing garbage collection with too little result. By default the JVM is configured to throw this error if it spends more than <strong>98% of the total time doing GC and when after the GC only less than 2% of the heap is recovered</strong>.</p><p>JVM抛出 <em>java.lang.OutOfMemoryError: GC overhead limit exceeded</em> 错误就是发出了这样的信号: 执行垃圾收集的时间比例太大, 有效的运算量太小. 默认情况下, 如果GC花费的时间超过 <strong>98%</strong>, 并且GC回收的内存少于 <strong>2%</strong>, JVM就会抛出这个错误。</p><p>接着，我们看下JVM内存分配：</p><p>使用<code>JPS</code>命令找出pid，使用<code>JMAP -heap ${pid}</code> 打印内存信息：</p><p>问题现场 heap信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 1638, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.191-b12</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2621440000 (2500.0MB)</span><br><span class="line">   NewSize                  = 873463808 (833.0MB)</span><br><span class="line">   MaxNewSize               = 873463808 (833.0MB)</span><br><span class="line">   OldSize                  = 1747976192 (1667.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 389021696 (371.0MB)</span><br><span class="line">   used     = 389021696 (371.0MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 218103808 (208.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 218103808 (208.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 242745344 (231.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 242745344 (231.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 1747976192 (1667.0MB)</span><br><span class="line">   used     = 1747822160 (1666.8531036376953MB)</span><br><span class="line">   free     = 154032 (0.1468963623046875MB)</span><br><span class="line">   99.99118798066559% used</span><br></pre></td></tr></table></figure><p>很显然，Eden区 和Old 区都耗尽了。</p><p>我想知道新生代和老年代都存了些什么，使用命令<code>jmap -dump:live,format=b,file=dump.file ${pid}</code> </p><p>只导出存活对象的堆栈信息</p><p>大概有3个G</p><p>使用工具分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The class "nz.net.ultraq.thymeleaf.context.extensions.IContextExtensions", loaded by "org.springframework.boot.loader.LaunchedURLClassLoader @ 0x7252ae050", occupies 2,099,455,296 (96.06%) bytes. The memory is accumulated in one instance of "java.util.LinkedHashMap" loaded by "&lt;system class loader&gt;".</span><br><span class="line"></span><br><span class="line">Keywords</span><br><span class="line">java.util.LinkedHashMap</span><br><span class="line">nz.net.ultraq.thymeleaf.context.extensions.IContextExtensions</span><br><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader @ <span class="number">0x7252ae050</span></span><br></pre></td></tr></table></figure><p>爆出了内存泄露风险：</p><p>继续看，主要看这个<code>Accumulated Objects in Dominator Tree</code>看看对象数量：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2fux0uq5j316a0gg7co.jpg" alt=""></p><p>96%的空间都被 thymeleaf context占用了</p><p>怀疑这个有内存泄露，这个类是使用thymeleaf的layout功能，第三方的jar包</p><p>google一番，github上面已经有人爆出了类似的BUG：</p><p><a href="https://github.com/ultraq/thymeleaf-layout-dialect/issues/139" target="_blank" rel="noopener">https://github.com/ultraq/thymeleaf-layout-dialect/issues/139</a></p><p><a href="https://github.com/ultraq/thymeleaf-layout-dialect/issues/122" target="_blank" rel="noopener">https://github.com/ultraq/thymeleaf-layout-dialect/issues/122</a></p><p>然后看帖子说，2.1.0已经解决了</p><p>看了下我用的版本是2.0.1 赶紧升级了最新版本；</p><p>运行一天结果：</p><p><code>jmap -heap ${pid}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID <span class="number">11332</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.191</span>-b12</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">4</span> thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2621440000</span> (<span class="number">2500.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">873463808</span> (<span class="number">833.0</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">873463808</span> (<span class="number">833.0</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">1747976192</span> (<span class="number">1667.0</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">829423616</span> (<span class="number">791.0</span>MB)</span><br><span class="line">   used     = <span class="number">23825784</span> (<span class="number">22.72203826904297</span>MB)</span><br><span class="line">   free     = <span class="number">805597832</span> (<span class="number">768.277961730957</span>MB)</span><br><span class="line">   <span class="number">2.8725712097399456</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">21495808</span> (<span class="number">20.5</span>MB)</span><br><span class="line">   used     = <span class="number">17248552</span> (<span class="number">16.449501037597656</span>MB)</span><br><span class="line">   free     = <span class="number">4247256</span> (<span class="number">4.050498962402344</span>MB)</span><br><span class="line">   <span class="number">80.24146847608613</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">1747976192</span> (<span class="number">1667.0</span>MB)</span><br><span class="line">   used     = <span class="number">102638624</span> (<span class="number">97.88381958007812</span>MB)</span><br><span class="line">   free     = <span class="number">1645337568</span> (<span class="number">1569.1161804199219</span>MB)</span><br><span class="line">   <span class="number">5.8718548038439184</span>% used</span><br></pre></td></tr></table></figure><p>可以看到，已经正常了；</p><p>继续看一下GC频率:<code>jstat -gc ${pid}</code></p><p>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>21504.0 21504.0  0.0   16127.9 809984.0 493815.0 1707008.0   100273.0  112844.0 107384.9 13056.0 12026.0    149    4.369   4      1.156    5.525</p><p>S0C 代表 S0 capacity S0 大小，注意单位是KB 大概21M左右</p><p>S1C代表 S1 capacity S1 大小，注意单位是KB 大概21M左右</p><p>S0U 代表 S0 used capacity ，S0区使用空间 同理 S1U代表 S1区使用空间</p><p>同理其他, C代表初始空间 U代表使用空间，YGC 代表youngCG (count)次数，FGCT 代表 young GC (cost time)</p><p>可以看到，Young GC 次数达到了149次，耗时4.369 s</p><p>继续看看垃圾回收日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T03:<span class="number">49</span>:<span class="number">51.797</span>+<span class="number">0800</span>: <span class="number">32225.690</span>: [GC (Allocation Failure)  <span class="number">926931</span>K-&gt;<span class="number">105742</span>K(<span class="number">2545152</span>K), <span class="number">0.0287966</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T03:<span class="number">57</span>:<span class="number">13.735</span>+<span class="number">0800</span>: <span class="number">32667.628</span>: [GC (Allocation Failure)  <span class="number">929038</span>K-&gt;<span class="number">106728</span>K(<span class="number">2545152</span>K), <span class="number">0.0513608</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">03</span>:<span class="number">53.071</span>+<span class="number">0800</span>: <span class="number">33066.965</span>: [GC (Allocation Failure)  <span class="number">930024</span>K-&gt;<span class="number">105097</span>K(<span class="number">2545152</span>K), <span class="number">0.0322447</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">11</span>:<span class="number">00.399</span>+<span class="number">0800</span>: <span class="number">33494.292</span>: [GC (Allocation Failure)  <span class="number">928393</span>K-&gt;<span class="number">105856</span>K(<span class="number">2545152</span>K), <span class="number">0.0323377</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">20</span>:<span class="number">46.614</span>+<span class="number">0800</span>: <span class="number">34080.507</span>: [GC (Allocation Failure)  <span class="number">929152</span>K-&gt;<span class="number">107559</span>K(<span class="number">2544640</span>K), <span class="number">0.0285097</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">29</span>:<span class="number">45.171</span>+<span class="number">0800</span>: <span class="number">34619.064</span>: [GC (Allocation Failure)  <span class="number">930855</span>K-&gt;<span class="number">106868</span>K(<span class="number">2545152</span>K), <span class="number">0.0304927</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">37</span>:<span class="number">42.922</span>+<span class="number">0800</span>: <span class="number">35096.815</span>: [GC (Allocation Failure)  <span class="number">930164</span>K-&gt;<span class="number">106172</span>K(<span class="number">2545664</span>K), <span class="number">0.0277129</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">42</span>:<span class="number">42.121</span>+<span class="number">0800</span>: <span class="number">35396.014</span>: [GC (Allocation Failure)  <span class="number">929980</span>K-&gt;<span class="number">104085</span>K(<span class="number">2545152</span>K), <span class="number">0.0260993</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">50</span>:<span class="number">59.664</span>+<span class="number">0800</span>: <span class="number">35893.557</span>: [GC (Allocation Failure)  <span class="number">927893</span>K-&gt;<span class="number">106575</span>K(<span class="number">2545664</span>K), <span class="number">0.0233603</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">57</span>:<span class="number">57.947</span>+<span class="number">0800</span>: <span class="number">36311.840</span>: [GC (Allocation Failure)  <span class="number">930383</span>K-&gt;<span class="number">106330</span>K(<span class="number">2545152</span>K), <span class="number">0.0338124</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T05:<span class="number">04</span>:<span class="number">59.016</span>+<span class="number">0800</span>: <span class="number">36732.909</span>: [GC (Allocation Failure)  <span class="number">930138</span>K-&gt;<span class="number">106005</span>K(<span class="number">2546176</span>K), <span class="number">0.0251955</span> secs]</span><br></pre></td></tr></table></figure><p>很多的 YGC ，可以看到 old区分配多，但是一直使用很少，我们需要把Eden区适当的调大一些</p><p>修改启动参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -XX:NewRatio=1 -XX:SurvivorRatio=6 -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.jar --spring.profiles.active=online &amp;</span><br></pre></td></tr></table></figure><p><code>jmap -heap pid</code>看下是否修改成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2621440000</span> (<span class="number">2500.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">1</span></span><br><span class="line">   SurvivorRatio            = <span class="number">6</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">1220542464</span> (<span class="number">1164.0</span>MB)</span><br><span class="line">   used     = <span class="number">323484472</span> (<span class="number">308.4988327026367</span>MB)</span><br><span class="line">   free     = <span class="number">897057992</span> (<span class="number">855.5011672973633</span>MB)</span><br><span class="line">   <span class="number">26.503336142838204</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">37224448</span> (<span class="number">35.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">37224448</span> (<span class="number">35.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">48758784</span> (<span class="number">46.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">48758784</span> (<span class="number">46.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   used     = <span class="number">85510744</span> (<span class="number">81.54940032958984</span>MB)</span><br><span class="line">   free     = <span class="number">1225209256</span> (<span class="number">1168.4505996704102</span>MB)</span><br><span class="line">   <span class="number">6.523952026367187</span>% used</span><br></pre></td></tr></table></figure><p>修改成功，看下 <code>jstat -gc pid</code></p><p>还是有FGC 和YGC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"><span class="number">47616.0</span> <span class="number">36352.0</span>  <span class="number">0.0</span>    <span class="number">0.0</span>   <span class="number">1191936.0</span> <span class="number">672473.0</span> <span class="number">1280000.0</span>   <span class="number">83506.6</span>   <span class="number">98380.0</span> <span class="number">94049.5</span> <span class="number">12160.0</span> <span class="number">11320.6</span>      <span class="number">7</span>    <span class="number">0.322</span>   <span class="number">4</span>      <span class="number">0.939</span>    <span class="number">1.262</span></span><br></pre></td></tr></table></figure><p>继续看下日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T10:<span class="number">56</span>:<span class="number">37.707</span>+<span class="number">0800</span>: <span class="number">17.685</span>: [<span class="function">Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  44082K-&gt;42892<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.1144814 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:41.840+0800: 21.817: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  884284K-&gt;49863<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0497769 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:41.889+0800: 21.867: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  49863K-&gt;30535<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.1049150 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:47.095+0800: 27.073: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  991047K-&gt;45635<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0237439 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:51.833+0800: 31.810: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  841845K-&gt;56284<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0595819 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:51.892+0800: 31.870: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  56284K-&gt;53312<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.2826614 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:57:00.632+0800: 40.609: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  1013824K-&gt;70909<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0262383 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:57:37.503+0800: 77.480: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  1031421K-&gt;85407<span class="title">K</span><span class="params">(<span class="number">2513920</span>K)</span>, 0.0557805 secs]</span></span><br><span class="line"><span class="function">2020-04-21T11:00:13.790+0800: 233.767: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  715074K-&gt;89727<span class="title">K</span><span class="params">(<span class="number">2508288</span>K)</span>, 0.0624448 secs]</span></span><br><span class="line"><span class="function">2020-04-21T11:00:13.853+0800: 233.830: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  89727K-&gt;83506<span class="title">K</span><span class="params">(<span class="number">2508288</span>K)</span>, 0.4372935 secs]</span></span><br></pre></td></tr></table></figure><p>可以看到是由于Metadata GC Threshold触发了FGC；MetaspaceSize 太小了。继续修改，增加参数：</p><p><code>-XX:MetaspaceSize=128M</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -XX:NewRatio=1 -XX:SurvivorRatio=6 -XX:MetaspaceSize=128M -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.jar --spring.profiles.active=online &amp;</span><br></pre></td></tr></table></figure><p>好了，GC基本没有，跑段时间在看</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近线上维护的一个程序经过微服务化之后，出现了很多GC，而且内存被耗尽，小网站，不应该耗尽4G内存,调查了一下原因，原来是&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kyro序列化错误</title>
    <link href="https://frank0.top/2019/11/21/kyro-error/"/>
    <id>https://frank0.top/2019/11/21/kyro-error/</id>
    <published>2019-11-21T10:59:09.000Z</published>
    <updated>2020-04-22T11:00:36.565Z</updated>
    
    <content type="html"><![CDATA[<p>Kryo序列化时报错：java.lang.ArrayIndexOutOfBoundsException、Buffer overflow</p><p>序列化二进制文件不完整</p><a id="more"></a><p>问题：</p><ol><li>序列化对象不完整</li><li>序列化对象比较慢，耗时10-14ms之内</li><li>解决比较慢的问题之后，又出现对象序列化数据不完整问题</li></ol><p>java序列化与kryo序列化得区别？</p><ol><li>效率比java序列化高，官方网站有性能测试</li><li>kryo不需要实现Serializable接口，而Java需要实现序列化接口</li><li>java 序列化支持实例化类的改变，但是kryo不支持；已经经过测试代码证实；</li><li>只导出存活对象的堆栈信息</li></ol><p>正确使用kryo的姿势：</p><ol><li>使用对象池来解决非线程安全的问题</li><li>使用Kryo提供的Output对象来获取byte数组，而Output是支持自动扩容的，大于4M的时候；</li></ol><p>池化技术：</p><p>数据库连接池，http连接池等；重复利用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化kryo池</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KryoPool kryoPool = <span class="keyword">new</span> KryoPool.Builder(<span class="keyword">new</span> KryoFactory() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Kryo <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">           kryo.setInstantiatorStrategy(<span class="keyword">new</span> Kryo.DefaultInstantiatorStrategy(<span class="keyword">new</span> StdInstantiatorStrategy()));</span><br><span class="line">           <span class="keyword">return</span> kryo;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).softReferences().build();</span><br></pre></td></tr></table></figure><p>Kryo池化，主要使用一个软引用队列，如果队列没有则使用工厂创建一个，如果队列有则从队列出队给使用者使用；</p><p>使用者使用完之后，进行释放，则kryo对象入队；这样保证kryo的重复利用；</p><p>自动扩容：</p><p>之前的错误原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates a new Output for writing to an OutputStream. A buffer size of 4096 is used. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Output</span> <span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">if</span> (outputStream == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"outputStream cannot be null."</span>);</span><br><span class="line"><span class="keyword">this</span>.outputStream = outputStream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Output</span> <span class="params">(<span class="keyword">int</span> bufferSize, <span class="keyword">int</span> maxBufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bufferSize &gt; maxBufferSize &amp;&amp; maxBufferSize != -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"bufferSize: "</span> + bufferSize + <span class="string">" cannot be greater than maxBufferSize: "</span> + maxBufferSize);</span><br><span class="line"><span class="keyword">if</span> (maxBufferSize &lt; -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxBufferSize cannot be &lt; -1: "</span> + maxBufferSize);</span><br><span class="line"><span class="keyword">this</span>.capacity = bufferSize;</span><br><span class="line"><span class="keyword">this</span>.maxCapacity = maxBufferSize == -<span class="number">1</span> ? Integer.MAX_VALUE : maxBufferSize;</span><br><span class="line">buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码以为是最大maxBuffer都是4KB导致的；其实不是，kryo支持自动扩容：</p><p>上面这个构造函数，如果指定了外部的一个OutputStream的话，他会每次达到Output的buffer的4096字节后，执行一次刷新操作，把这4096字节刷新到指定的那个输出流，然后清空buffer，继续执行序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeVarInt</span> <span class="params">(<span class="keyword">int</span> value, <span class="keyword">boolean</span> optimizePositive)</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!optimizePositive) value = (value &lt;&lt; <span class="number">1</span>) ^ (value &gt;&gt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">if</span> (value &gt;&gt;&gt; <span class="number">7</span> == <span class="number">0</span>) &#123;</span><br><span class="line">require(<span class="number">1</span>);</span><br><span class="line">buffer[position++] = (<span class="keyword">byte</span>)value;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> true if the buffer has been resized. */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">require</span> <span class="params">(<span class="keyword">int</span> required)</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line">        <span class="comment">//初始容量够用</span></span><br><span class="line"><span class="keyword">if</span> (capacity - position &gt;= required) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 申请空间大于最大容量值</span></span><br><span class="line">        <span class="keyword">if</span> (required &gt; maxCapacity)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(<span class="string">"Buffer overflow. Max capacity: "</span> + maxCapacity + <span class="string">", required: "</span> + required);</span><br><span class="line">        <span class="comment">//刷新缓存</span></span><br><span class="line">flush();</span><br><span class="line">        <span class="comment">//如果没有使用 outputStream，则需要设置最大容量，未超过最大容量则自动扩容</span></span><br><span class="line"><span class="keyword">while</span> (capacity - position &lt; required) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == maxCapacity)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(<span class="string">"Buffer overflow. Available: "</span> + (capacity - position) + <span class="string">", required: "</span> + required);</span><br><span class="line"><span class="comment">// Grow buffer.</span></span><br><span class="line">            <span class="comment">//自动扩容</span></span><br><span class="line"><span class="keyword">if</span> (capacity == <span class="number">0</span>) capacity = <span class="number">1</span>;</span><br><span class="line">capacity = Math.min(capacity * <span class="number">2</span>, maxCapacity);</span><br><span class="line"><span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) capacity = maxCapacity;</span><br><span class="line"><span class="keyword">byte</span>[] newBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[capacity];</span><br><span class="line">System.arraycopy(buffer, <span class="number">0</span>, newBuffer, <span class="number">0</span>, position);</span><br><span class="line">buffer = newBuffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Writes the buffered bytes to the underlying OutputStream, if any. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span> <span class="params">()</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有设置outputStream 则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (outputStream == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//刷缓存到outputStream</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream.write(buffer, <span class="number">0</span>, position);</span><br><span class="line">outputStream.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(ex);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//重置当前写入位置</span></span><br><span class="line">total += position;</span><br><span class="line">position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，正确使用kryo的用法有两种：</p><ul><li>使用最大容量控制对象大小，此时如果序列化大对象超过则扩容，需要设置maxCapacity</li><li>使用outputStream来获取真实的对象字节流，这个kryo会自动刷缓存到outputStream中。无需设置maxCapacity</li></ul><p>使用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用outputStream，需要使用size控制</span></span><br><span class="line">Output output = <span class="keyword">new</span> Output(<span class="number">4096</span>,<span class="number">4096</span>*<span class="number">4</span>);</span><br><span class="line">kryo = kryoPool.borrow();</span><br><span class="line">kryo.writeObject(output, obj);</span><br><span class="line">output.close();</span><br><span class="line">bytes[] bytes = output.toBytes();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 使用outputStream</span></span><br><span class="line">         ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         Output output = <span class="keyword">new</span> Output(outputStream);</span><br><span class="line">         kryo = kryoPool.borrow();</span><br><span class="line">         kryo.writeObject(output, obj);</span><br><span class="line">         output.close();</span><br><span class="line"><span class="comment">//此处需要注意，outputStream的结果输出</span></span><br><span class="line">         bytes = outputStream.toByteArray();</span><br></pre></td></tr></table></figure><p>之前的代码把这两种方式进行混用了。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerialize</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TestSerialize t = <span class="keyword">new</span> TestSerialize();</span><br><span class="line">        <span class="comment">//t.testKryo();</span></span><br><span class="line">        t.testKryoD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKryo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        u.setName(<span class="string">"sdfsdf"</span>);</span><br><span class="line">        u.setUserId(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] serialize = KryoSerializer.serialize(u);</span><br><span class="line">        FileOutputStream fileWriter = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/k.bin"</span>));</span><br><span class="line">        fileWriter.write(serialize);</span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKryoD</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"d:/k.bin"</span>));</span><br><span class="line">        <span class="comment">//当文件没有结束时，每次读取一个字节显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(data);</span><br><span class="line">        in.close();</span><br><span class="line">        User user = KryoSerializer.deSerialize(data, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJava</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//        u.setUserId(1);</span></span><br><span class="line">        u.setName(<span class="string">"2323"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] serialize = JavaSerializer.serialize(u);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileWriter = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/u.bin"</span>));</span><br><span class="line">        fileWriter.write(serialize);</span><br><span class="line">        fileWriter.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJavaD</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"d:/u.bin"</span>));</span><br><span class="line">        <span class="comment">//当文件没有结束时，每次读取一个字节显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(data);</span><br><span class="line">        in.close();</span><br><span class="line">        User user = JavaSerializer.deSerialize(data, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">229880032075948565L</span>;</span><br><span class="line">        <span class="keyword">private</span> Integer userId;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kryo序列化时报错：java.lang.ArrayIndexOutOfBoundsException、Buffer overflow&lt;/p&gt;
&lt;p&gt;序列化二进制文件不完整&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDK8-dynamic-proxy</title>
    <link href="https://frank0.top/2019/04/16/JDK8-dynamic-proxy/"/>
    <id>https://frank0.top/2019/04/16/JDK8-dynamic-proxy/</id>
    <published>2019-04-16T09:28:00.000Z</published>
    <updated>2020-04-22T10:43:17.706Z</updated>
    
    <content type="html"><![CDATA[<p>Jdk动态代理（基于JDK8）原理浅析</p><a id="more"></a><blockquote><p>Jdk动态代理（基于JDK8）原理浅析</p></blockquote><p>JDK动态代理很容易使用，但是光知道使用不行，还得知道JDK的动态代理是怎么实现的。<br>我们例子:<br>定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Click</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickImpl</span> <span class="keyword">implements</span> <span class="title">Click</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call click action..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理的InvokerHandler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickInvokerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClickInvokerHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般此类可以使用单例模式；<br>测试JDK动态代理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; proxyClass= Proxy.getProxyClass(JdkProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">Click</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = proxyClass.getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = <span class="keyword">new</span> ClickInvokerHandler(<span class="keyword">new</span> ClickImpl());</span><br><span class="line">        Click click= (Click)cons.newInstance(ih);</span><br><span class="line">        click.click();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        Click click1=(Click)Proxy.</span><br><span class="line">                newProxyInstance(JdkProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                        new Class&lt;?&gt;[]&#123;Click.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> ClickInvokerHandler(<span class="keyword">new</span> ClickImpl()));</span><br><span class="line">        click1.click();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call click action...</span><br><span class="line">--------------------------------</span><br><span class="line">call click action...</span><br></pre></td></tr></table></figure><p>下面我们带着两个问题看Jdk动态代理原理：</p><ul><li>怎么生成代理类？</li><li>InvokerHandler的invoker方法是谁在调用？</li><li>生成的代理类如何加载到JVM中?</li></ul><p>#####如果生成代理类？</p><p>我们可以看看<code>Proxy.newProxyInstance</code>方法<br>此方法需要三个参数，classLoader,接口定义类数组(click.class),InvocationHandler 实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line">     Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是生成了代理类，我们继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先从缓存中获取，如果没有创建过，则使用ProxyClassFactory进行创建</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从proxyClassCache中获取，我们看看proxyClassCache怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>感兴趣的可以看看这个<code>WeakCache</code>get()方法，使用了内部类<code>ProxyClassFactory.apply()</code>来创建代理类，并缓存。<br>1.apply方法里面定义了代理类的类名；<br>2.生成代理类的字节码，并加载代理类；<br>生成代理类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure><p><code>generateProxyClass</code>方法中调用<code>generateClassFile</code>方法生成class文件；<br>可以使用<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>参数来配置，是否保存生成的代理类的class文件；<br>感兴趣的可以看下<code>generateClassFile</code>这个方法；这个方法默认实现了，Object的hashCode,equals,toString方法；</p><p>加载类使用我们classloader来加载：<br>这个方法是个<code>native</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length)</span><br></pre></td></tr></table></figure><p>OK,到这里我们看到了怎么生成代理类；这个代理类怎么加载到JVM；<br>但是我们还没有看到：invokerHandler的invoker方法何时被调用？<br>我们设置配置：<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>为true；<br>然后可以看到已经生成了代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Click</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">////...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">////...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">       <span class="comment">//...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.tsoft.learning.proxy.dynamic.Click"</span>).getMethod(<span class="string">"click"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类继承至<code>Proxy</code>类，实现了<code>Click</code>接口。<br>注意static静态块中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m3 = Class.forName(<span class="string">"com.tsoft.learning.proxy.dynamic.Click"</span>).getMethod(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure><p>从接口中获取方法，如果需要代理接口中没有的方法，就不能使用JDK动态代理。此时，我们需要依靠cglib来做动态代理了。这就是为什么JDK的动态代理需要实现接口的原因。<br>我们在看看 <code>$Proxy0</code>中的<code>click</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>里面实际上调用super.h.invoke这个方法，  而这个h对象就是我们的之前的入参：<code>ClickInvokerHandler</code>对象；这个对象是使用构成方法注入进去的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ok，到此，我们提出的三个问题已经回答完毕。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jdk动态代理（基于JDK8）原理浅析&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
