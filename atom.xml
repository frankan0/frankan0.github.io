<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>frank0&#39;s Blog</title>
  
  <subtitle>maker&amp;coder&amp;father</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://blog.onenavigation.com/"/>
  <updated>2020-04-22T10:58:58.198Z</updated>
  <id>http://blog.onenavigation.com/</id>
  
  <author>
    <name>frank0</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Thymeleaf-Layout引起的内存泄露</title>
    <link href="http://blog.onenavigation.com/2020/04/22/Thymeleaf-Layout-GC-Error/"/>
    <id>http://blog.onenavigation.com/2020/04/22/Thymeleaf-Layout-GC-Error/</id>
    <published>2020-04-22T04:17:43.000Z</published>
    <updated>2020-04-22T10:58:58.198Z</updated>
    
    <content type="html"><![CDATA[<p>最近线上维护的一个程序经过微服务化之后，出现了很多GC，而且内存被耗尽，小网站，不应该耗尽4G内存,调查了一下原因，原来是</p><a id="more"></a><p>服务器硬件信息：</p><p>SSD: 80 GB RAID-10<br>RAM: 4096 MB<br>CPU: 2x Intel Xeon</p><p>软件信息：</p><p>MySQL,Redis,JDK8,SpringBoot,Thymeleaf</p><p>JVM参数：<code>/opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.0.0.1-SNAPSHOT.jar --spring.profiles.active=online</code></p><p>用来跑了一些Java程序，运行一天之后，出现OOM异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">org.springframework.web.util.NestedServletException: Handler dispatch failed; nested exception is java.lang.OutOfMemoryError: GC overhead limit exceeded</span><br></pre></td></tr></table></figure><p>GC overhead limit exceeded异常，GOOGLE一番：</p><p>The <em>java.lang.OutOfMemoryError: GC overhead limit exceeded</em> error is the JVM’s way of signalling that your application spends too much time doing garbage collection with too little result. By default the JVM is configured to throw this error if it spends more than <strong>98% of the total time doing GC and when after the GC only less than 2% of the heap is recovered</strong>.</p><p>JVM抛出 <em>java.lang.OutOfMemoryError: GC overhead limit exceeded</em> 错误就是发出了这样的信号: 执行垃圾收集的时间比例太大, 有效的运算量太小. 默认情况下, 如果GC花费的时间超过 <strong>98%</strong>, 并且GC回收的内存少于 <strong>2%</strong>, JVM就会抛出这个错误。</p><p>接着，我们看下JVM内存分配：</p><p>使用<code>JPS</code>命令找出pid，使用<code>JMAP -heap ${pid}</code> 打印内存信息：</p><p>问题现场 heap信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID 1638, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is 25.191-b12</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with 4 thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = 0</span><br><span class="line">   MaxHeapFreeRatio         = 100</span><br><span class="line">   MaxHeapSize              = 2621440000 (2500.0MB)</span><br><span class="line">   NewSize                  = 873463808 (833.0MB)</span><br><span class="line">   MaxNewSize               = 873463808 (833.0MB)</span><br><span class="line">   OldSize                  = 1747976192 (1667.0MB)</span><br><span class="line">   NewRatio                 = 2</span><br><span class="line">   SurvivorRatio            = 8</span><br><span class="line">   MetaspaceSize            = 21807104 (20.796875MB)</span><br><span class="line">   CompressedClassSpaceSize = 1073741824 (1024.0MB)</span><br><span class="line">   MaxMetaspaceSize         = 17592186044415 MB</span><br><span class="line">   G1HeapRegionSize         = 0 (0.0MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = 389021696 (371.0MB)</span><br><span class="line">   used     = 389021696 (371.0MB)</span><br><span class="line">   free     = 0 (0.0MB)</span><br><span class="line">   100.0% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = 218103808 (208.0MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 218103808 (208.0MB)</span><br><span class="line">   0.0% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = 242745344 (231.5MB)</span><br><span class="line">   used     = 0 (0.0MB)</span><br><span class="line">   free     = 242745344 (231.5MB)</span><br><span class="line">   0.0% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = 1747976192 (1667.0MB)</span><br><span class="line">   used     = 1747822160 (1666.8531036376953MB)</span><br><span class="line">   free     = 154032 (0.1468963623046875MB)</span><br><span class="line">   99.99118798066559% used</span><br></pre></td></tr></table></figure><p>很显然，Eden区 和Old 区都耗尽了。</p><p>我想知道新生代和老年代都存了些什么，使用命令<code>jmap -dump:live,format=b,file=dump.file ${pid}</code> </p><p>只导出存活对象的堆栈信息</p><p>大概有3个G</p><p>使用工具分析一下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">The class "nz.net.ultraq.thymeleaf.context.extensions.IContextExtensions", loaded by "org.springframework.boot.loader.LaunchedURLClassLoader @ 0x7252ae050", occupies 2,099,455,296 (96.06%) bytes. The memory is accumulated in one instance of "java.util.LinkedHashMap" loaded by "&lt;system class loader&gt;".</span><br><span class="line"></span><br><span class="line">Keywords</span><br><span class="line">java.util.LinkedHashMap</span><br><span class="line">nz.net.ultraq.thymeleaf.context.extensions.IContextExtensions</span><br><span class="line">org.springframework.boot.loader.LaunchedURLClassLoader @ <span class="number">0x7252ae050</span></span><br></pre></td></tr></table></figure><p>爆出了内存泄露风险：</p><p>继续看，主要看这个<code>Accumulated Objects in Dominator Tree</code>看看对象数量：</p><p><img src="https://tva1.sinaimg.cn/large/007S8ZIlly1ge2fux0uq5j316a0gg7co.jpg" alt=""></p><p>96%的空间都被 thymeleaf context占用了</p><p>怀疑这个有内存泄露，这个类是使用thymeleaf的layout功能，第三方的jar包</p><p>google一番，github上面已经有人爆出了类似的BUG：</p><p><a href="https://github.com/ultraq/thymeleaf-layout-dialect/issues/139" target="_blank" rel="noopener">https://github.com/ultraq/thymeleaf-layout-dialect/issues/139</a></p><p><a href="https://github.com/ultraq/thymeleaf-layout-dialect/issues/122" target="_blank" rel="noopener">https://github.com/ultraq/thymeleaf-layout-dialect/issues/122</a></p><p>然后看帖子说，2.1.0已经解决了</p><p>看了下我用的版本是2.0.1 赶紧升级了最新版本；</p><p>运行一天结果：</p><p><code>jmap -heap ${pid}</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">Attaching to process ID <span class="number">11332</span>, please wait...</span><br><span class="line">Debugger attached successfully.</span><br><span class="line">Server compiler detected.</span><br><span class="line">JVM version is <span class="number">25.191</span>-b12</span><br><span class="line"></span><br><span class="line">using thread-local object allocation.</span><br><span class="line">Parallel GC with <span class="number">4</span> thread(s)</span><br><span class="line"></span><br><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2621440000</span> (<span class="number">2500.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">873463808</span> (<span class="number">833.0</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">873463808</span> (<span class="number">833.0</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">1747976192</span> (<span class="number">1667.0</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">2</span></span><br><span class="line">   SurvivorRatio            = <span class="number">8</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">829423616</span> (<span class="number">791.0</span>MB)</span><br><span class="line">   used     = <span class="number">23825784</span> (<span class="number">22.72203826904297</span>MB)</span><br><span class="line">   free     = <span class="number">805597832</span> (<span class="number">768.277961730957</span>MB)</span><br><span class="line">   <span class="number">2.8725712097399456</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">21495808</span> (<span class="number">20.5</span>MB)</span><br><span class="line">   used     = <span class="number">17248552</span> (<span class="number">16.449501037597656</span>MB)</span><br><span class="line">   free     = <span class="number">4247256</span> (<span class="number">4.050498962402344</span>MB)</span><br><span class="line">   <span class="number">80.24146847608613</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">22020096</span> (<span class="number">21.0</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">1747976192</span> (<span class="number">1667.0</span>MB)</span><br><span class="line">   used     = <span class="number">102638624</span> (<span class="number">97.88381958007812</span>MB)</span><br><span class="line">   free     = <span class="number">1645337568</span> (<span class="number">1569.1161804199219</span>MB)</span><br><span class="line">   <span class="number">5.8718548038439184</span>% used</span><br></pre></td></tr></table></figure><p>可以看到，已经正常了；</p><p>继续看一下GC频率:<code>jstat -gc ${pid}</code></p><p>S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT<br>21504.0 21504.0  0.0   16127.9 809984.0 493815.0 1707008.0   100273.0  112844.0 107384.9 13056.0 12026.0    149    4.369   4      1.156    5.525</p><p>S0C 代表 S0 capacity S0 大小，注意单位是KB 大概21M左右</p><p>S1C代表 S1 capacity S1 大小，注意单位是KB 大概21M左右</p><p>S0U 代表 S0 used capacity ，S0区使用空间 同理 S1U代表 S1区使用空间</p><p>同理其他, C代表初始空间 U代表使用空间，YGC 代表youngCG (count)次数，FGCT 代表 young GC (cost time)</p><p>可以看到，Young GC 次数达到了149次，耗时4.369 s</p><p>继续看看垃圾回收日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T03:<span class="number">49</span>:<span class="number">51.797</span>+<span class="number">0800</span>: <span class="number">32225.690</span>: [GC (Allocation Failure)  <span class="number">926931</span>K-&gt;<span class="number">105742</span>K(<span class="number">2545152</span>K), <span class="number">0.0287966</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T03:<span class="number">57</span>:<span class="number">13.735</span>+<span class="number">0800</span>: <span class="number">32667.628</span>: [GC (Allocation Failure)  <span class="number">929038</span>K-&gt;<span class="number">106728</span>K(<span class="number">2545152</span>K), <span class="number">0.0513608</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">03</span>:<span class="number">53.071</span>+<span class="number">0800</span>: <span class="number">33066.965</span>: [GC (Allocation Failure)  <span class="number">930024</span>K-&gt;<span class="number">105097</span>K(<span class="number">2545152</span>K), <span class="number">0.0322447</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">11</span>:<span class="number">00.399</span>+<span class="number">0800</span>: <span class="number">33494.292</span>: [GC (Allocation Failure)  <span class="number">928393</span>K-&gt;<span class="number">105856</span>K(<span class="number">2545152</span>K), <span class="number">0.0323377</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">20</span>:<span class="number">46.614</span>+<span class="number">0800</span>: <span class="number">34080.507</span>: [GC (Allocation Failure)  <span class="number">929152</span>K-&gt;<span class="number">107559</span>K(<span class="number">2544640</span>K), <span class="number">0.0285097</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">29</span>:<span class="number">45.171</span>+<span class="number">0800</span>: <span class="number">34619.064</span>: [GC (Allocation Failure)  <span class="number">930855</span>K-&gt;<span class="number">106868</span>K(<span class="number">2545152</span>K), <span class="number">0.0304927</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">37</span>:<span class="number">42.922</span>+<span class="number">0800</span>: <span class="number">35096.815</span>: [GC (Allocation Failure)  <span class="number">930164</span>K-&gt;<span class="number">106172</span>K(<span class="number">2545664</span>K), <span class="number">0.0277129</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">42</span>:<span class="number">42.121</span>+<span class="number">0800</span>: <span class="number">35396.014</span>: [GC (Allocation Failure)  <span class="number">929980</span>K-&gt;<span class="number">104085</span>K(<span class="number">2545152</span>K), <span class="number">0.0260993</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">50</span>:<span class="number">59.664</span>+<span class="number">0800</span>: <span class="number">35893.557</span>: [GC (Allocation Failure)  <span class="number">927893</span>K-&gt;<span class="number">106575</span>K(<span class="number">2545664</span>K), <span class="number">0.0233603</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T04:<span class="number">57</span>:<span class="number">57.947</span>+<span class="number">0800</span>: <span class="number">36311.840</span>: [GC (Allocation Failure)  <span class="number">930383</span>K-&gt;<span class="number">106330</span>K(<span class="number">2545152</span>K), <span class="number">0.0338124</span> secs]</span><br><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T05:<span class="number">04</span>:<span class="number">59.016</span>+<span class="number">0800</span>: <span class="number">36732.909</span>: [GC (Allocation Failure)  <span class="number">930138</span>K-&gt;<span class="number">106005</span>K(<span class="number">2546176</span>K), <span class="number">0.0251955</span> secs]</span><br></pre></td></tr></table></figure><p>很多的 YGC ，可以看到 old区分配多，但是一直使用很少，我们需要把Eden区适当的调大一些</p><p>修改启动参数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -XX:NewRatio=1 -XX:SurvivorRatio=6 -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.jar --spring.profiles.active=online &amp;</span><br></pre></td></tr></table></figure><p><code>jmap -heap pid</code>看下是否修改成功：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Heap Configuration:</span><br><span class="line">   MinHeapFreeRatio         = <span class="number">0</span></span><br><span class="line">   MaxHeapFreeRatio         = <span class="number">100</span></span><br><span class="line">   MaxHeapSize              = <span class="number">2621440000</span> (<span class="number">2500.0</span>MB)</span><br><span class="line">   NewSize                  = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   MaxNewSize               = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   OldSize                  = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   NewRatio                 = <span class="number">1</span></span><br><span class="line">   SurvivorRatio            = <span class="number">6</span></span><br><span class="line">   MetaspaceSize            = <span class="number">21807104</span> (<span class="number">20.796875</span>MB)</span><br><span class="line">   CompressedClassSpaceSize = <span class="number">1073741824</span> (<span class="number">1024.0</span>MB)</span><br><span class="line">   MaxMetaspaceSize         = <span class="number">17592186044415</span> MB</span><br><span class="line">   G1HeapRegionSize         = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line"></span><br><span class="line">Heap Usage:</span><br><span class="line">PS Young Generation</span><br><span class="line">Eden Space:</span><br><span class="line">   capacity = <span class="number">1220542464</span> (<span class="number">1164.0</span>MB)</span><br><span class="line">   used     = <span class="number">323484472</span> (<span class="number">308.4988327026367</span>MB)</span><br><span class="line">   free     = <span class="number">897057992</span> (<span class="number">855.5011672973633</span>MB)</span><br><span class="line">   <span class="number">26.503336142838204</span>% used</span><br><span class="line">From Space:</span><br><span class="line">   capacity = <span class="number">37224448</span> (<span class="number">35.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">37224448</span> (<span class="number">35.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">To Space:</span><br><span class="line">   capacity = <span class="number">48758784</span> (<span class="number">46.5</span>MB)</span><br><span class="line">   used     = <span class="number">0</span> (<span class="number">0.0</span>MB)</span><br><span class="line">   free     = <span class="number">48758784</span> (<span class="number">46.5</span>MB)</span><br><span class="line">   <span class="number">0.0</span>% used</span><br><span class="line">PS Old Generation</span><br><span class="line">   capacity = <span class="number">1310720000</span> (<span class="number">1250.0</span>MB)</span><br><span class="line">   used     = <span class="number">85510744</span> (<span class="number">81.54940032958984</span>MB)</span><br><span class="line">   free     = <span class="number">1225209256</span> (<span class="number">1168.4505996704102</span>MB)</span><br><span class="line">   <span class="number">6.523952026367187</span>% used</span><br></pre></td></tr></table></figure><p>修改成功，看下 <code>jstat -gc pid</code></p><p>还是有FGC 和YGC：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">S0C    S1C    S0U    S1U      EC       EU        OC         OU       MC     MU    CCSC   CCSU   YGC     YGCT    FGC    FGCT     GCT</span><br><span class="line"><span class="number">47616.0</span> <span class="number">36352.0</span>  <span class="number">0.0</span>    <span class="number">0.0</span>   <span class="number">1191936.0</span> <span class="number">672473.0</span> <span class="number">1280000.0</span>   <span class="number">83506.6</span>   <span class="number">98380.0</span> <span class="number">94049.5</span> <span class="number">12160.0</span> <span class="number">11320.6</span>      <span class="number">7</span>    <span class="number">0.322</span>   <span class="number">4</span>      <span class="number">0.939</span>    <span class="number">1.262</span></span><br></pre></td></tr></table></figure><p>继续看下日志：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2020</span>-<span class="number">04</span>-<span class="number">21</span>T10:<span class="number">56</span>:<span class="number">37.707</span>+<span class="number">0800</span>: <span class="number">17.685</span>: [<span class="function">Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  44082K-&gt;42892<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.1144814 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:41.840+0800: 21.817: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  884284K-&gt;49863<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0497769 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:41.889+0800: 21.867: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  49863K-&gt;30535<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.1049150 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:47.095+0800: 27.073: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  991047K-&gt;45635<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0237439 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:51.833+0800: 31.810: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  841845K-&gt;56284<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0595819 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:56:51.892+0800: 31.870: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  56284K-&gt;53312<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.2826614 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:57:00.632+0800: 40.609: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  1013824K-&gt;70909<span class="title">K</span><span class="params">(<span class="number">2400256</span>K)</span>, 0.0262383 secs]</span></span><br><span class="line"><span class="function">2020-04-21T10:57:37.503+0800: 77.480: [<span class="title">GC</span> <span class="params">(Allocation Failure)</span>  1031421K-&gt;85407<span class="title">K</span><span class="params">(<span class="number">2513920</span>K)</span>, 0.0557805 secs]</span></span><br><span class="line"><span class="function">2020-04-21T11:00:13.790+0800: 233.767: [<span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  715074K-&gt;89727<span class="title">K</span><span class="params">(<span class="number">2508288</span>K)</span>, 0.0624448 secs]</span></span><br><span class="line"><span class="function">2020-04-21T11:00:13.853+0800: 233.830: [Full <span class="title">GC</span> <span class="params">(Metadata GC Threshold)</span>  89727K-&gt;83506<span class="title">K</span><span class="params">(<span class="number">2508288</span>K)</span>, 0.4372935 secs]</span></span><br></pre></td></tr></table></figure><p>可以看到是由于Metadata GC Threshold触发了FGC；MetaspaceSize 太小了。继续修改，增加参数：</p><p><code>-XX:MetaspaceSize=128M</code></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">nohup /opt/jdk1.8.0_191/bin/java -jar -Xloggc:/opt/mb-gc.log -XX:+PrintGC -XX:+PrintGCDateStamps -XX:NewRatio=1 -XX:SurvivorRatio=6 -XX:MetaspaceSize=128M -Xms2500m -Xmx2500m -javaagent:/opt/tingyun/tingyun-agent-java.jar /demo.jar --spring.profiles.active=online &amp;</span><br></pre></td></tr></table></figure><p>好了，GC基本没有，跑段时间在看</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近线上维护的一个程序经过微服务化之后，出现了很多GC，而且内存被耗尽，小网站，不应该耗尽4G内存,调查了一下原因，原来是&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>kyro序列化错误</title>
    <link href="http://blog.onenavigation.com/2019/11/21/kyro-error/"/>
    <id>http://blog.onenavigation.com/2019/11/21/kyro-error/</id>
    <published>2019-11-21T10:59:09.000Z</published>
    <updated>2020-04-22T11:00:36.565Z</updated>
    
    <content type="html"><![CDATA[<p>Kryo序列化时报错：java.lang.ArrayIndexOutOfBoundsException、Buffer overflow</p><p>序列化二进制文件不完整</p><a id="more"></a><p>问题：</p><ol><li>序列化对象不完整</li><li>序列化对象比较慢，耗时10-14ms之内</li><li>解决比较慢的问题之后，又出现对象序列化数据不完整问题</li></ol><p>java序列化与kryo序列化得区别？</p><ol><li>效率比java序列化高，官方网站有性能测试</li><li>kryo不需要实现Serializable接口，而Java需要实现序列化接口</li><li>java 序列化支持实例化类的改变，但是kryo不支持；已经经过测试代码证实；</li><li>只导出存活对象的堆栈信息</li></ol><p>正确使用kryo的姿势：</p><ol><li>使用对象池来解决非线程安全的问题</li><li>使用Kryo提供的Output对象来获取byte数组，而Output是支持自动扩容的，大于4M的时候；</li></ol><p>池化技术：</p><p>数据库连接池，http连接池等；重复利用；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 初始化kryo池</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> KryoPool kryoPool = <span class="keyword">new</span> KryoPool.Builder(<span class="keyword">new</span> KryoFactory() &#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> Kryo <span class="title">create</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           Kryo kryo = <span class="keyword">new</span> Kryo();</span><br><span class="line">           kryo.setInstantiatorStrategy(<span class="keyword">new</span> Kryo.DefaultInstantiatorStrategy(<span class="keyword">new</span> StdInstantiatorStrategy()));</span><br><span class="line">           <span class="keyword">return</span> kryo;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;).softReferences().build();</span><br></pre></td></tr></table></figure><p>Kryo池化，主要使用一个软引用队列，如果队列没有则使用工厂创建一个，如果队列有则从队列出队给使用者使用；</p><p>使用者使用完之后，进行释放，则kryo对象入队；这样保证kryo的重复利用；</p><p>自动扩容：</p><p>之前的错误原因：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Creates a new Output for writing to an OutputStream. A buffer size of 4096 is used. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Output</span> <span class="params">(OutputStream outputStream)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>(<span class="number">4096</span>, <span class="number">4096</span>);</span><br><span class="line"><span class="keyword">if</span> (outputStream == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"outputStream cannot be null."</span>);</span><br><span class="line"><span class="keyword">this</span>.outputStream = outputStream;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Output</span> <span class="params">(<span class="keyword">int</span> bufferSize, <span class="keyword">int</span> maxBufferSize)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (bufferSize &gt; maxBufferSize &amp;&amp; maxBufferSize != -<span class="number">1</span>)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"bufferSize: "</span> + bufferSize + <span class="string">" cannot be greater than maxBufferSize: "</span> + maxBufferSize);</span><br><span class="line"><span class="keyword">if</span> (maxBufferSize &lt; -<span class="number">1</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"maxBufferSize cannot be &lt; -1: "</span> + maxBufferSize);</span><br><span class="line"><span class="keyword">this</span>.capacity = bufferSize;</span><br><span class="line"><span class="keyword">this</span>.maxCapacity = maxBufferSize == -<span class="number">1</span> ? Integer.MAX_VALUE : maxBufferSize;</span><br><span class="line">buffer = <span class="keyword">new</span> <span class="keyword">byte</span>[bufferSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看源码以为是最大maxBuffer都是4KB导致的；其实不是，kryo支持自动扩容：</p><p>上面这个构造函数，如果指定了外部的一个OutputStream的话，他会每次达到Output的buffer的4096字节后，执行一次刷新操作，把这4096字节刷新到指定的那个输出流，然后清空buffer，继续执行序列化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">writeVarInt</span> <span class="params">(<span class="keyword">int</span> value, <span class="keyword">boolean</span> optimizePositive)</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!optimizePositive) value = (value &lt;&lt; <span class="number">1</span>) ^ (value &gt;&gt; <span class="number">31</span>);</span><br><span class="line"><span class="keyword">if</span> (value &gt;&gt;&gt; <span class="number">7</span> == <span class="number">0</span>) &#123;</span><br><span class="line">require(<span class="number">1</span>);</span><br><span class="line">buffer[position++] = (<span class="keyword">byte</span>)value;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** <span class="doctag">@return</span> true if the buffer has been resized. */</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">require</span> <span class="params">(<span class="keyword">int</span> required)</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line">        <span class="comment">//初始容量够用</span></span><br><span class="line"><span class="keyword">if</span> (capacity - position &gt;= required) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"><span class="comment">// 申请空间大于最大容量值</span></span><br><span class="line">        <span class="keyword">if</span> (required &gt; maxCapacity)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(<span class="string">"Buffer overflow. Max capacity: "</span> + maxCapacity + <span class="string">", required: "</span> + required);</span><br><span class="line">        <span class="comment">//刷新缓存</span></span><br><span class="line">flush();</span><br><span class="line">        <span class="comment">//如果没有使用 outputStream，则需要设置最大容量，未超过最大容量则自动扩容</span></span><br><span class="line"><span class="keyword">while</span> (capacity - position &lt; required) &#123;</span><br><span class="line"><span class="keyword">if</span> (capacity == maxCapacity)</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(<span class="string">"Buffer overflow. Available: "</span> + (capacity - position) + <span class="string">", required: "</span> + required);</span><br><span class="line"><span class="comment">// Grow buffer.</span></span><br><span class="line">            <span class="comment">//自动扩容</span></span><br><span class="line"><span class="keyword">if</span> (capacity == <span class="number">0</span>) capacity = <span class="number">1</span>;</span><br><span class="line">capacity = Math.min(capacity * <span class="number">2</span>, maxCapacity);</span><br><span class="line"><span class="keyword">if</span> (capacity &lt; <span class="number">0</span>) capacity = maxCapacity;</span><br><span class="line"><span class="keyword">byte</span>[] newBuffer = <span class="keyword">new</span> <span class="keyword">byte</span>[capacity];</span><br><span class="line">System.arraycopy(buffer, <span class="number">0</span>, newBuffer, <span class="number">0</span>, position);</span><br><span class="line">buffer = newBuffer;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Writes the buffered bytes to the underlying OutputStream, if any. */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span> <span class="params">()</span> <span class="keyword">throws</span> KryoException </span>&#123;</span><br><span class="line">        <span class="comment">//如果没有设置outputStream 则直接返回</span></span><br><span class="line"><span class="keyword">if</span> (outputStream == <span class="keyword">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//刷缓存到outputStream</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">outputStream.write(buffer, <span class="number">0</span>, position);</span><br><span class="line">outputStream.flush();</span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException ex) &#123;</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> KryoException(ex);</span><br><span class="line">&#125;</span><br><span class="line">        <span class="comment">//重置当前写入位置</span></span><br><span class="line">total += position;</span><br><span class="line">position = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实，正确使用kryo的用法有两种：</p><ul><li>使用最大容量控制对象大小，此时如果序列化大对象超过则扩容，需要设置maxCapacity</li><li>使用outputStream来获取真实的对象字节流，这个kryo会自动刷缓存到outputStream中。无需设置maxCapacity</li></ul><p>使用代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不使用outputStream，需要使用size控制</span></span><br><span class="line">Output output = <span class="keyword">new</span> Output(<span class="number">4096</span>,<span class="number">4096</span>*<span class="number">4</span>);</span><br><span class="line">kryo = kryoPool.borrow();</span><br><span class="line">kryo.writeObject(output, obj);</span><br><span class="line">output.close();</span><br><span class="line">bytes[] bytes = output.toBytes();</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">         <span class="comment">// 使用outputStream</span></span><br><span class="line">         ByteArrayOutputStream outputStream = <span class="keyword">new</span> ByteArrayOutputStream();</span><br><span class="line">         Output output = <span class="keyword">new</span> Output(outputStream);</span><br><span class="line">         kryo = kryoPool.borrow();</span><br><span class="line">         kryo.writeObject(output, obj);</span><br><span class="line">         output.close();</span><br><span class="line"><span class="comment">//此处需要注意，outputStream的结果输出</span></span><br><span class="line">         bytes = outputStream.toByteArray();</span><br></pre></td></tr></table></figure><p>之前的代码把这两种方式进行混用了。</p><p>测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSerialize</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        TestSerialize t = <span class="keyword">new</span> TestSerialize();</span><br><span class="line">        <span class="comment">//t.testKryo();</span></span><br><span class="line">        t.testKryoD();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKryo</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line">        u.setName(<span class="string">"sdfsdf"</span>);</span><br><span class="line">        u.setUserId(<span class="number">11</span>);</span><br><span class="line">        <span class="keyword">byte</span>[] serialize = KryoSerializer.serialize(u);</span><br><span class="line">        FileOutputStream fileWriter = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/k.bin"</span>));</span><br><span class="line">        fileWriter.write(serialize);</span><br><span class="line">        fileWriter.close();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testKryoD</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"d:/k.bin"</span>));</span><br><span class="line">        <span class="comment">//当文件没有结束时，每次读取一个字节显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(data);</span><br><span class="line">        in.close();</span><br><span class="line">        User user = KryoSerializer.deSerialize(data, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJava</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        User u = <span class="keyword">new</span> User();</span><br><span class="line"><span class="comment">//        u.setUserId(1);</span></span><br><span class="line">        u.setName(<span class="string">"2323"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">byte</span>[] serialize = JavaSerializer.serialize(u);</span><br><span class="line"></span><br><span class="line">        FileOutputStream fileWriter = <span class="keyword">new</span> FileOutputStream(<span class="keyword">new</span> File(<span class="string">"d:/u.bin"</span>));</span><br><span class="line">        fileWriter.write(serialize);</span><br><span class="line">        fileWriter.close();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testJavaD</span><span class="params">()</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        FileInputStream in =<span class="keyword">new</span> FileInputStream(<span class="keyword">new</span> File(<span class="string">"d:/u.bin"</span>));</span><br><span class="line">        <span class="comment">//当文件没有结束时，每次读取一个字节显示</span></span><br><span class="line">        <span class="keyword">byte</span>[] data=<span class="keyword">new</span> <span class="keyword">byte</span>[in.available()];</span><br><span class="line">        in.read(data);</span><br><span class="line">        in.close();</span><br><span class="line">        User user = JavaSerializer.deSerialize(data, User<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        System.out.println(user.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">229880032075948565L</span>;</span><br><span class="line">        <span class="keyword">private</span> Integer userId;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        <span class="keyword">private</span> String sex;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Kryo序列化时报错：java.lang.ArrayIndexOutOfBoundsException、Buffer overflow&lt;/p&gt;
&lt;p&gt;序列化二进制文件不完整&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>JDK8-dynamic-proxy</title>
    <link href="http://blog.onenavigation.com/2019/04/16/JDK8-dynamic-proxy/"/>
    <id>http://blog.onenavigation.com/2019/04/16/JDK8-dynamic-proxy/</id>
    <published>2019-04-16T09:28:00.000Z</published>
    <updated>2020-04-22T10:43:17.706Z</updated>
    
    <content type="html"><![CDATA[<p>Jdk动态代理（基于JDK8）原理浅析</p><a id="more"></a><blockquote><p>Jdk动态代理（基于JDK8）原理浅析</p></blockquote><p>JDK动态代理很容易使用，但是光知道使用不行，还得知道JDK的动态代理是怎么实现的。<br>我们例子:<br>定义一个接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Click</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">click</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickImpl</span> <span class="keyword">implements</span> <span class="title">Click</span></span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"call click action..."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>动态代理的InvokerHandler:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ClickInvokerHandler</span> <span class="keyword">implements</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Object target;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">ClickInvokerHandler</span><span class="params">(Object target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.target = target;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> method.invoke(target,args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一般此类可以使用单例模式；<br>测试JDK动态代理的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Class&lt;?&gt; proxyClass= Proxy.getProxyClass(JdkProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),<span class="title">Click</span>.<span class="title">class</span>)</span>;</span><br><span class="line">        <span class="keyword">final</span> Constructor&lt;?&gt; cons = proxyClass.getConstructor(InvocationHandler<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="keyword">final</span> InvocationHandler ih = <span class="keyword">new</span> ClickInvokerHandler(<span class="keyword">new</span> ClickImpl());</span><br><span class="line">        Click click= (Click)cons.newInstance(ih);</span><br><span class="line">        click.click();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"--------------------------------"</span>);</span><br><span class="line">        Click click1=(Click)Proxy.</span><br><span class="line">                newProxyInstance(JdkProxyTest<span class="class">.<span class="keyword">class</span>.<span class="title">getClassLoader</span>(),</span></span><br><span class="line">                        new Class&lt;?&gt;[]&#123;Click.class&#125;,</span><br><span class="line">                        <span class="keyword">new</span> ClickInvokerHandler(<span class="keyword">new</span> ClickImpl()));</span><br><span class="line">        click1.click();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>打印数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">call click action...</span><br><span class="line">--------------------------------</span><br><span class="line">call click action...</span><br></pre></td></tr></table></figure><p>下面我们带着两个问题看Jdk动态代理原理：</p><ul><li>怎么生成代理类？</li><li>InvokerHandler的invoker方法是谁在调用？</li><li>生成的代理类如何加载到JVM中?</li></ul><p>#####如果生成代理类？</p><p>我们可以看看<code>Proxy.newProxyInstance</code>方法<br>此方法需要三个参数，classLoader,接口定义类数组(click.class),InvocationHandler 实例；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InvocationHandler h)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> IllegalArgumentException</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line">     Class&lt;?&gt; cl = getProxyClass0(loader, intfs);</span><br><span class="line">    <span class="comment">//...略</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法就是生成了代理类，我们继续：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> Class&lt;?&gt; getProxyClass0(ClassLoader loader,</span><br><span class="line">                                           Class&lt;?&gt;... interfaces) &#123;</span><br><span class="line">        <span class="keyword">if</span> (interfaces.length &gt; <span class="number">65535</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"interface limit exceeded"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//首先从缓存中获取，如果没有创建过，则使用ProxyClassFactory进行创建</span></span><br><span class="line">        <span class="keyword">return</span> proxyClassCache.get(loader, interfaces);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>从proxyClassCache中获取，我们看看proxyClassCache怎么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> WeakCache&lt;ClassLoader, Class&lt;?&gt;[], Class&lt;?&gt;&gt;</span><br><span class="line">        proxyClassCache = <span class="keyword">new</span> WeakCache&lt;&gt;(<span class="keyword">new</span> KeyFactory(), <span class="keyword">new</span> ProxyClassFactory());</span><br></pre></td></tr></table></figure><p>感兴趣的可以看看这个<code>WeakCache</code>get()方法，使用了内部类<code>ProxyClassFactory.apply()</code>来创建代理类，并缓存。<br>1.apply方法里面定义了代理类的类名；<br>2.生成代理类的字节码，并加载代理类；<br>生成代理类文件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">byte</span>[] proxyClassFile = ProxyGenerator.generateProxyClass(</span><br><span class="line">               proxyName, interfaces, accessFlags);</span><br></pre></td></tr></table></figure><p><code>generateProxyClass</code>方法中调用<code>generateClassFile</code>方法生成class文件；<br>可以使用<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>参数来配置，是否保存生成的代理类的class文件；<br>感兴趣的可以看下<code>generateClassFile</code>这个方法；这个方法默认实现了，Object的hashCode,equals,toString方法；</p><p>加载类使用我们classloader来加载：<br>这个方法是个<code>native</code>方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">defineClass0(loader, proxyName,</span><br><span class="line">                                    proxyClassFile, <span class="number">0</span>, proxyClassFile.length)</span><br></pre></td></tr></table></figure><p>OK,到这里我们看到了怎么生成代理类；这个代理类怎么加载到JVM；<br>但是我们还没有看到：invokerHandler的invoker方法何时被调用？<br>我们设置配置：<code>sun.misc.ProxyGenerator.saveGeneratedFiles</code>为true；<br>然后可以看到已经生成了代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> $<span class="title">Proxy0</span> <span class="keyword">extends</span> <span class="title">Proxy</span> <span class="keyword">implements</span> <span class="title">Click</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m1;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m3;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m2;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Method m0;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object var1)</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">////...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">//...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> String <span class="title">toString</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="comment">////...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">       <span class="comment">//...略</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            m1 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"equals"</span>, Class.forName(<span class="string">"java.lang.Object"</span>));</span><br><span class="line">            m3 = Class.forName(<span class="string">"com.tsoft.learning.proxy.dynamic.Click"</span>).getMethod(<span class="string">"click"</span>);</span><br><span class="line">            m2 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"toString"</span>);</span><br><span class="line">            m0 = Class.forName(<span class="string">"java.lang.Object"</span>).getMethod(<span class="string">"hashCode"</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (NoSuchMethodException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchMethodError(var2.getMessage());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (ClassNotFoundException var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NoClassDefFoundError(var3.getMessage());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>代理类继承至<code>Proxy</code>类，实现了<code>Click</code>接口。<br>注意static静态块中的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">m3 = Class.forName(<span class="string">"com.tsoft.learning.proxy.dynamic.Click"</span>).getMethod(<span class="string">"click"</span>);</span><br></pre></td></tr></table></figure><p>从接口中获取方法，如果需要代理接口中没有的方法，就不能使用JDK动态代理。此时，我们需要依靠cglib来做动态代理了。这就是为什么JDK的动态代理需要实现接口的原因。<br>我们在看看 <code>$Proxy0</code>中的<code>click</code>方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">click</span><span class="params">()</span> <span class="keyword">throws</span>  </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">super</span>.h.invoke(<span class="keyword">this</span>, m3, (Object[])<span class="keyword">null</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (RuntimeException | Error var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> var2;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> UndeclaredThrowableException(var3);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>里面实际上调用super.h.invoke这个方法，  而这个h对象就是我们的之前的入参：<code>ClickInvokerHandler</code>对象；这个对象是使用构成方法注入进去的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> $Proxy0(InvocationHandler var1) <span class="keyword">throws</span>  &#123;</span><br><span class="line">        <span class="keyword">super</span>(var1);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>ok，到此，我们提出的三个问题已经回答完毕。    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Jdk动态代理（基于JDK8）原理浅析&lt;/p&gt;
    
    </summary>
    
    
    
  </entry>
  
</feed>
